<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>黄欢的博客</title>
    <description>北京网易有道后台研发工程师</description>
    <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/</link>
    <atom:link href="http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 05 Jun 2016 12:00:49 +0800</pubDate>
    <lastBuildDate>Sun, 05 Jun 2016 12:00:49 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>什么是数据库事务？</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;事务的定义　&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;为什么需要事务？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;事务的几大特性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql&quot; id=&quot;markdown-toc-mysql&quot;&gt;MySQL对事务的支持&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;事务的定义　&lt;/h2&gt;

&lt;p&gt;引用一段wikipedia中对数据库事务的定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A transaction symbolizes a unit of work performed within a database management system (or similar system) against a database, and treated in a coherent and reliable way independent of other transactions.  A transaction generally represents any change in database. Transactions in a database environment have two main purposes:&lt;/p&gt;

  &lt;blockquote&gt;
    &lt;ol&gt;
      &lt;li&gt;To provide reliable units of work that allow correct recovery from failures and keep a database consistent even in cases of system failure, when execution stops (completely or partially) and many operations upon a database remain uncompleted, with unclear status.&lt;/li&gt;
      &lt;li&gt;To provide isolation between programs accessing a database concurrently. If this isolation is not provided, the programs’ outcomes are possibly erroneous.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;对应的可以理解为：事务是数据库的基本工作单元，它以all-or-nothing的方式执行，让数据库从一个一致的状态转移到另一个一致的状态。即使系统发生故障，未执行完成的事务依然可以正确恢复，而事务之间可以在不同程度上进行隔离，以保证数据的正确性。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;为什么需要事务？&lt;/h2&gt;

&lt;p&gt;事务是为了保证数据库中数据的完整性和正确性。设想没有正确的事务支持，就可能出现A向B转账，A的钱被扣掉，而B却并没收到钱的情况。事务能保证要么A转账成功，或则失败，而A和B的钱的总额保持一致的状态。事务能够为我们的所有操作保证可确定的结果，在这样的前提下，我们才能进行各种各样的操作。&lt;/p&gt;

&lt;p&gt;值得一提的时候，对于简单的网页应用，可能其后台仅有一个数据库，是单点的事务。而在更多的生产系统中，数据源往往不只一个，包含不同类型的数据库,MQ等，这个时候还需要分布式事务（XA事务）的支持才能保证正确性，单点的事务往往由数据库等系统本身保证，而分布式事务还需要上层中间件的支持。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;事务的几大特性&lt;/h2&gt;

&lt;p&gt;事务的几大特性ACID可以说是老生常谈了，这里先列举一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;原子性：原子性保证一个事务中的所有操作要么全部执行，要么全部不执行（执行中出错则全部回滚）&lt;/li&gt;
  &lt;li&gt;一致性：事务将使数据库从一个有效的状态转换到另一个有效的状态，满足定义的所有规则，包括约束，级联，触发器等。&lt;/li&gt;
  &lt;li&gt;隔离性：事务之间的执行是相互隔离的&lt;/li&gt;
  &lt;li&gt;持久性：已提交的事务，将会对数据库产生永久的影响&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下一章将详细解释事务的隔离性。&lt;/p&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL对事务的支持&lt;/h2&gt;

&lt;p&gt;MySQL是互联网企业中用的最多的数据库，大家都知道使用InnoDB或则BerkeleyDB作为存储引擎才支持事务，之后的章节都将默认以MySQL作为范例，采用InnoDB作为存储引擎。&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Jun 2016 10:15:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/framework/2016/06/05/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/framework/2016/06/05/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1.html</guid>
        
        
        <category>Framework</category>
        
      </item>
    
      <item>
        <title>详解Spring事务</title>
        <description>&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://sadwxqezc.github.io/HuangHuanBlog/framework/2016/06/05/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1.html&quot;&gt;详解Spring事务：什么是事务?&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;&quot;&gt;详解Spring事务：事务的隔离性&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;&quot;&gt;详解Spring事务：Spring的事务管理&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;&quot;&gt;详解Spring事务：Spring中事务的Propagation&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;&quot;&gt;详解Spring事务：XA事务&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 02 Jun 2016 17:03:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/framework/2016/06/02/%E8%AF%A6%E8%A7%A3Spring%E4%BA%8B%E5%8A%A1.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/framework/2016/06/02/%E8%AF%A6%E8%A7%A3Spring%E4%BA%8B%E5%8A%A1.html</guid>
        
        
        <category>Framework</category>
        
      </item>
    
      <item>
        <title>Spring分布式事务配置(atomikos)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;开发原因&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;开发组件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;开发思路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;实现细节&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#pom&quot; id=&quot;markdown-toc-pom&quot;&gt;Pom依赖&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#atomikos&quot; id=&quot;markdown-toc-atomikos&quot;&gt;Atomikos配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;测试&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;开发原因&lt;/h2&gt;

&lt;p&gt;在Java后端开发过程中事务控制非常重要，而Spring为我们提供了方便的声明式事务方法&lt;code class=&quot;highlighter-rouge&quot;&gt;@transactional&lt;/code&gt;。但是默认的Spring事务只支持单数据源，而实际上一个系统往往需要写多个数据源，这个时候我们就需要考虑如何通过Spring实现对分布式事务的支持。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;开发组件&lt;/h2&gt;

&lt;p&gt;框架：SpringBoot&lt;br /&gt;
组件：Atomikos&lt;br /&gt;
IDE：Intellij&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;开发思路&lt;/h2&gt;

&lt;p&gt;对于分布式事务而言，&lt;code class=&quot;highlighter-rouge&quot;&gt;JTA&lt;/code&gt;是一个不错的解决方案，通常&lt;code class=&quot;highlighter-rouge&quot;&gt;JTA&lt;/code&gt;需要应用服务器的支持，但在查阅&lt;code class=&quot;highlighter-rouge&quot;&gt;SpringBoot&lt;/code&gt;的文档时发现，它推荐了&lt;code class=&quot;highlighter-rouge&quot;&gt;Atomikos&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Bitronix&lt;/code&gt;两种无需服务器支持的分布式事务组件，文档内容如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Spring Boot supports distributed JTA transactions across multiple XA resources using either an &lt;code class=&quot;highlighter-rouge&quot;&gt;Atomikos&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitronix&lt;/code&gt; embedded transaction manager. JTA transactions are also supported when deploying to a suitable Java EE Application Server.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这两个组件中，&lt;code class=&quot;highlighter-rouge&quot;&gt;Atomikos&lt;/code&gt;更受大家的好评，所以我选择使用它：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Atomikos is a popular open source transaction manager which can be embedded into your Spring Boot application. You can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;spring-boot-starter-jta-atomikos&lt;/code&gt; Starter POM to pull in the appropriate Atomikos libraries. Spring Boot will auto-configure Atomikos and ensure that appropriate depends-on settings are applied to your Spring beans for correct startup and shutdown ordering.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;实现细节&lt;/h2&gt;

&lt;h3 id=&quot;pom&quot;&gt;Pom依赖&lt;/h3&gt;

&lt;p&gt;就如上面文档内容所说，要在SpringBoot中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;atomikos&lt;/code&gt;，仅需要添加一个依赖，这也是SpringBoot非常便利的地方：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-jta-atomikos&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;atomikos&quot;&gt;Atomikos配置&lt;/h3&gt;

&lt;p&gt;值得一提的是，Spring支持通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;配置bean，和通过&lt;code class=&quot;highlighter-rouge&quot;&gt;annotation&lt;/code&gt;配置bean两种方式，在这里我们采用后者，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;方式真是太烦人。方式的配置方法其实很简单，只需要在注解了&lt;code class=&quot;highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;的类里面，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;来配置，详细的配置内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/************************** atomikos 多数据源配置 ***************************/

/*------- db1 -------*/

/**
 * db1的 XA datasource
 *
 * @return
 */
@Bean
@Primary
@Qualifier(&quot;db1&quot;)
public AtomikosDataSourceBean db1DataSourceBean() {
    AtomikosDataSourceBean atomikosDataSourceBean = new AtomikosDataSourceBean();
    atomikosDataSourceBean.setUniqueResourceName(&quot;db1&quot;);
    atomikosDataSourceBean.setXaDataSourceClassName(
            &quot;com.mysql.jdbc.jdbc2.optional.MysqlXADataSource&quot;);
    Properties properties = new Properties();
    properties.put(&quot;URL&quot;, db1_url);
    properties.put(&quot;user&quot;, db1_username);
    properties.put(&quot;password&quot;, db1_password);
    atomikosDataSourceBean.setXaProperties(properties);
    return atomikosDataSourceBean;
}

/**
 * 构造db1 sessionFactory
 *
 * @return
 */
@Bean
@Autowired
public AnnotationSessionFactoryBean sessionFactory(@Qualifier(&quot;db1&quot;) AtomikosDataSourceBean atomikosDataSourceBean) {
    AnnotationSessionFactoryBean sessionFactory = new AnnotationSessionFactoryBean();
    sessionFactory.setDataSource(atomikosDataSourceBean);
    sessionFactory.setPackagesToScan(db1_entity_package);
    Properties properties = new Properties();
    properties.put(&quot;hibernate.dialect&quot;, &quot;org.hibernate.dialect.MySQLInnoDBDialect&quot;);
    properties.put(&quot;hibernate.show_sql&quot;, &quot;false&quot;);
    properties.put(&quot;hibernate.format_sql&quot;, &quot;format&quot;);
    properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;true&quot;);
    properties.put(&quot;hibernate.connection.url&quot;, atomikosDataSourceBean.getXaProperties().get(&quot;URL&quot;));
    properties.put(&quot;hibernate.connection.driver_class&quot;, &quot;com.mysql.jdbc.Driver&quot;);
    sessionFactory.setHibernateProperties(properties);
    return sessionFactory;
}

/*------- db2 -------*/

/**
 * db2的 XA datasource
 *
 * @return
 */
@Bean
@Qualifier(&quot;db2&quot;)
public AtomikosDataSourceBean db2DataSourceBean() {
    AtomikosDataSourceBean atomikosDataSourceBean = new AtomikosDataSourceBean();
    atomikosDataSourceBean.setUniqueResourceName(&quot;db2&quot;);
    atomikosDataSourceBean.setXaDataSourceClassName(
            &quot;com.mysql.jdbc.jdbc2.optional.MysqlXADataSource&quot;);
    Properties properties = new Properties();
    properties.put(&quot;URL&quot;, db2_url);
    properties.put(&quot;user&quot;, db2_username);
    properties.put(&quot;password&quot;, db2_password);
    atomikosDataSourceBean.setXaProperties(properties);
    return atomikosDataSourceBean;
}

/**
 * 构造db2 sessionFactory
 *
 * @return
 */
@Bean
@Autowired
public AnnotationSessionFactoryBean db2SessionFactory(
        @Qualifier(&quot;db2&quot;) AtomikosDataSourceBean atomikosDataSourceBean) {
    AnnotationSessionFactoryBean sessionFactory = new AnnotationSessionFactoryBean();
    sessionFactory.setDataSource(atomikosDataSourceBean);
    sessionFactory.setPackagesToScan(db2_entity_package);
    Properties properties = new Properties();
    properties.put(&quot;hibernate.dialect&quot;, &quot;org.hibernate.dialect.MySQLInnoDBDialect&quot;);
    properties.put(&quot;hibernate.show_sql&quot;, &quot;false&quot;);
    properties.put(&quot;hibernate.format_sql&quot;, &quot;format&quot;);
    properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;true&quot;);
    properties.put(&quot;hibernate.connection.url&quot;, atomikosDataSourceBean.getXaProperties().get(&quot;URL&quot;));
    properties.put(&quot;hibernate.connection.driver_class&quot;, &quot;com.mysql.jdbc.Driver&quot;);
    sessionFactory.setHibernateProperties(properties);
    return sessionFactory;
}

/*--------- atomikos -----------*/

/**
 * transaction manager
 *
 * @return
 */
@Bean(destroyMethod = &quot;close&quot;, initMethod = &quot;init&quot;)
public UserTransactionManager userTransactionManager() {
    UserTransactionManager userTransactionManager = new UserTransactionManager();
    userTransactionManager.setForceShutdown(false);
    return userTransactionManager;
}

/**
 * jta transactionManager
 *
 * @return
 */
@Bean
public JtaTransactionManager transactionManager() {
    JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
    jtaTransactionManager.setTransactionManager(userTransactionManager());
    return jtaTransactionManager;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在该配置类上，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@EnableTransactionManagement&lt;/code&gt;来启用事务管理，该注解会自动通过&lt;code class=&quot;highlighter-rouge&quot;&gt;by-type&lt;/code&gt;查找满足条件的&lt;code class=&quot;highlighter-rouge&quot;&gt;PlatformTransactionManager&lt;/code&gt;。其实通过上面的范例可以发现，该配置与我们通常单数据源配置所不同的是使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;AtomikosDataSourceBean&lt;/code&gt;来配置数据源，以及定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;UserTransactionManager&lt;/code&gt;，更详细的配置方法可以参见&lt;a href=&quot;https://www.atomikos.com/Documentation/SpringIntegration&quot;&gt;Atomikos Spring Integration&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Atomikos&lt;/code&gt;的参数配置可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jta.propertis&lt;/code&gt;来配置，这里我主要配置了日志的输出位置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# log
com.atomikos.icatch.service=com.atomikos.icatch.standalone.UserTransactionServiceFactory
com.atomikos.icatch.log_base_dir=translogs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一开始我觉得这不过是&lt;code class=&quot;highlighter-rouge&quot;&gt;Atomikos&lt;/code&gt;自己打的一些纪录日志，没什么用，干脆关掉得了，但通过查阅资料发现并不是这样。&lt;code class=&quot;highlighter-rouge&quot;&gt;Atomikos&lt;/code&gt;就是通过这些日志来保障事务过程的（比如进程挂了后怎么恢复），所以千万不能关，关于这点可参考文章&lt;a href=&quot;http://blog.csdn.net/hengyunabc/article/details/19433947&quot;&gt;扯淡下XA事务&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;至此为止，配置就完成了，之后只需要再需要事务控制的地方加上&lt;code class=&quot;highlighter-rouge&quot;&gt;@transactional&lt;/code&gt;注解即可。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;测试用的&lt;code class=&quot;highlighter-rouge&quot;&gt;MultiDataSourceTransTest&lt;/code&gt;类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Autowired
private DB1TestDao db1Dao;

@Autowired
private DB2TestDaO db2Dao;

@Test
@Transactional
public void testMulitSourceTransaction() {
    db1Dao.saveOrUpdate(new TestEntity());
    db2Dao.saveOrUpdate(new TestEntity());
}

@Test
@Transactional
@Rollback(false)
public void testMulitSourceTransactionWithOutRollBack() {
    db1Dao.saveOrUpdate(new TestEntity());
    db2Dao.saveOrUpdate(new TestEntity());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于SpringBoot的单元测试配置请参见&lt;a href=&quot;http://127.0.0.1:4000/HuangHuanBlog/linux/2016/05/21/AOP%E4%B9%8BantiXSS.html&quot;&gt;AOP之AntiXSS&lt;/a&gt;中的范例，在SpringBoot的测试中，默认带有&lt;code class=&quot;highlighter-rouge&quot;&gt;@transactionl&lt;/code&gt;的测试会回滚，也就是执行完了啥也没变，所以可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@Rollback(false)&lt;/code&gt;来强制不回滚，通过对比回滚和不回滚的执行结果，就能测试分布式事务是否得到了支持。&lt;/p&gt;
</description>
        <pubDate>Sun, 29 May 2016 15:32:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/framework/2016/05/29/Spring%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/framework/2016/05/29/Spring%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE.html</guid>
        
        
        <category>Framework</category>
        
      </item>
    
      <item>
        <title>读书笔记-思</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;1. 万历十五年&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#this-is-water&quot; id=&quot;markdown-toc-this-is-water&quot;&gt;2. This is Water&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;3. 看见&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;4. 最好的告别&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;5. 追风筝的人&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 万历十五年&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;[美]黄仁宇著&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/wanli.jpg&quot; alt=&quot;万历十五年&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在看《万历十五年》之前，我先读完了整套《明朝那些事》，算是对整个明史有了一个全局的了解。《明朝那些事》算是在用网络小说的手法写历史，带入了较多作者个人的感情，每次人物总结会有一定的美化倾向，不够客观。但《明朝》这本书虽然不客观，却也不离谱，论述皆依据史实，同时文笔诙谐幽默，尤其对人物的描写着重笔墨，读起来通俗易懂，充满乐趣。因此，《明朝那些事》是文言文阅读能力有限的大众了解明史的较好途径，其中对于明朝政治，经济，军事等细节皆有描述，譬如“火耗”，“东林党”，&quot;心学&quot;等名词在其中有详尽的解释，能够大大降低阅读《万历十五年》的难度。&lt;/p&gt;

&lt;p&gt;万历十五年即为1587年，作者认为这一年为明朝历史的转折点，这个帝国从此走向灭亡。而我对本书的理解是，其作为转折点的原因有二：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;万历皇帝的怠政&lt;/li&gt;
  &lt;li&gt;国家的积弊：长期的以道德代替法律治理国家，以及文官治国发展到了一个顶峰，国家的体制已经凝固，难以改革。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然历史读起来会让人觉得事情都是理所当然的发生，但黄仁宇先生却以1587年为剖面，分析了人在其中的推动作用，这是尤为难得的贡献。而他在书中的分析也让人明白，即使人在历史中起了重大的推动作用，但该发生的事情却早晚必会发生。明朝的实际主人是文人阶层，底层人民受他们的统治。底层的人通过几代人的努力才有可能通过科举进入文人阶层，而文人阶层也只是为了维护国家的稳定，他们以道德约束这个有千万个农村构成的国家，却根本无心推动社会的发展。如此的社会循环所维持的时间能到达300年，之后则朝代更替再来一次。看历史总会有中悲凉的感觉，似乎所有的事情都是循环往复发生，有种宿命论的感觉。然而社会制度的变迁，其触发的源头却往往从技术的革新开始，而技术革新的本源来自于人们探索的精神。我想无论是制度，技术，主义，它们实际也只是人们探索的产物，而这种探索的精神为什么又只有人类才有，于其它地球生物上却并未看到。这样的精神是人先天就存在的，还是因为一些偶然和巧合正好赋予在人的身上了，这让我颇为费解。&lt;/p&gt;

&lt;h2 id=&quot;this-is-water&quot;&gt;2. This is Water&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;By David Foster Wallace&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/this_is_water.jpg&quot; alt=&quot;this is water&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在繁琐无聊的日常中，日复一日地保持自觉与警醒，困难得不可想象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;视频链接：&lt;a href=&quot;http://v.youku.com/v_show/id_XNjYyMjYzNDky.html?from=y1.2-1-103.3.4-1.1-1-1-3-0#paction&quot;&gt;生命中最简单又最困难的事&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2016年2月24日：写给将要参加工作的自己，莫要被生活所淹没，选择思考的方式，保持自觉与警醒。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3. 看见&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;柴静&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/kanjian.jpeg&quot; alt=&quot;kanjian&quot; /&gt;&lt;/p&gt;

&lt;p&gt;柴静的这本书，给我最大的震动便如书中所说的“真实自有万钧之力”，“人生是一个摆脱矇昧的过程”，要接近“真实”需要去感受的勇气和能力。能够感受才能够理解，在理解的基础上才能正确的思考，以接近“真实”，获取宽容的能力。但这需要一个过程，需要在生活中摔打和淬炼，要理解自己的弱点，也能理解别人的弱点，但要克服弱点并不是一个快速的过程，毕竟“如果人的弱点那么容易被克服，还要这么长的人生干什么”。而如果不正视自己的弱点，去感受和接受，时间只会带来经验的积累，却不会带来成长。&lt;/p&gt;

&lt;p&gt;感谢柴静这本书，让我知道了她“看见”的历程。虽然对于柴静人们各有褒贬，但既然能看见她的缺点和局限，也应能看到她的努力和思考，我相信今后的某个时刻，我会因为自己的生活，而回过头来再看这本书，寻求启发。毕竟柴静也是通过那么丰富的人生经历才能悟出一些道理，我也不可能只是靠多读几本书就能“看见”一切，还是要在真实的生活中磨砺。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;4. 最好的告别&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;By Atul Gavande&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/being_mortal.jpg&quot; alt=&quot;Being Mortal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是一本见证了太多生死的医生写出来的书，如果人能够仅仅因为衰老，而在爱的人的身边平静离去，那将是每个人都期望的告别。但这本书用实际的例子告诉我们，人的衰老是必然的，也许技术可以延长这个过程，但往往伴随着痛苦的代价。’being mortal’，我们都是凡人，会经历亲人的衰老，也会迎来自己的衰老，在这个过程之中，我们需要接受现实，去尽可能的选择亲人或自己更想要的结果，做最好的告别。&lt;/p&gt;

&lt;p&gt;很多豆瓣读者会说书中作者并没有说清楚什么时候应该放手，什么时候应该告别。但其实作者已经说的很清楚，告别的时机并不因该由医生决定，医生是作为一个解释者的角色，而决定主要来自于患者自身的意愿，而家人应该在此基础上，帮助患者找到最好的告别方式。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;5. 追风筝的人&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;By Khaled Hosseini&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/kiteRunner.jpeg&quot; alt=&quot;Kite Runner&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相信很多人会被那句“为你，千千万万遍”所打动，这也是贯穿全文的一句话，而最后哈桑的遭遇也令人叹息。
但整篇小说我认为最为成功的人物塑造是“父亲”，这个角色具有很多面：“冷漠的父亲”，“成功的商人”，“象征着勇气的英雄”，“思想自由的阿富汗人”，“和仆人的妻子有染的可憎的人”，“朋友”。我们或多或少能够在他是身上找到自己父亲的影子，对于男孩子来说，与父亲的关系往往很难如母亲那般亲近，年幼的时候会对父亲的威严感到畏惧，而长大了之后很多时候是用“朋友”的方式和父亲相处，之间总是隐隐有那么一堵墙，而能透过这堵墙的，是那斩不断的血脉联系。&lt;/p&gt;

&lt;p&gt;这篇小说中的“父亲”让我似乎明白了什么是生命的延续，也许对于“父亲”来说，不论孩子是否令自己满意，那总是他们身上的一种责任，一份宿命，一份存在的意义，他们会愿意为此做任何的事情，这样他们才能像书中的“父亲”一样平静的离开。实际上这是身处各个阶层的父亲都在做的事，作为“孩子”却不应该把这当作理所当然，理解这份平凡的伟大，it’s what makes us better than us!&lt;/p&gt;
</description>
        <pubDate>Sat, 21 May 2016 20:49:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/read/2016/05/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%80%9D.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/read/2016/05/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%80%9D.html</guid>
        
        
        <category>Read</category>
        
      </item>
    
      <item>
        <title>利用AOP进行Dao层antiXSS过滤</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;开发原因&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;开发组件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;开发思路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;实现细节&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;注解&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;注解的实现&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;测试&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;开发原因&lt;/h2&gt;

&lt;p&gt;在后台开发过程中，往往需要对用户的输入进行antiXSS等ßΩ过滤，以防止被攻击。以Dao层为例，这一层在写入数据库之前，应该对数据进行过滤，此时对应的一般是&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;saveOrUpdate()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;update()&lt;/code&gt;操作，输入多数情况下是基本类型或者对于数据库实体的&lt;code class=&quot;highlighter-rouge&quot;&gt;Entity&lt;/code&gt;。如果按照以往的写法，主要需要对&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;类型的数据（包括&lt;code class=&quot;highlighter-rouge&quot;&gt;Entity&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; Field）进行过滤，这时往往需要为对应的字段调用&lt;code class=&quot;highlighter-rouge&quot;&gt;antiXSS()&lt;/code&gt;方法，造成大量的&lt;code class=&quot;highlighter-rouge&quot;&gt;get/set&lt;/code&gt;代码，颇为麻烦，也造成代码冗长。因此，既然&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;具有强大的&lt;code class=&quot;highlighter-rouge&quot;&gt;AOP&lt;/code&gt;功能，不妨尝试用它简化这一过程。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;开发组件&lt;/h2&gt;

&lt;p&gt;SpringBoot，Intellij，Lombok(一个用于消除&lt;code class=&quot;highlighter-rouge&quot;&gt;get/set&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;hashcode&lt;/code&gt;这类代码的工具)&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;开发思路&lt;/h2&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;AOP&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;doAround&lt;/code&gt;方法截取传入参数，并利用反射筛选出其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; Filed进行antiXSS处理。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;实现细节&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;注解&lt;/h3&gt;

&lt;p&gt;首先需要定义一个专门用来对方法进行antiXSS处理的注解：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package beijing.huanghuan.anotations;

import java.lang.annotation.*;

/**
 * AntiXSS注解
 * &amp;lt;p/&amp;gt;
 * Created by huanghuan on 16/5/21.
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface AntiXSS {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;注解的实现&lt;/h3&gt;

&lt;p&gt;定义一个&lt;code class=&quot;highlighter-rouge&quot;&gt;AntiXSSAspect&lt;/code&gt;来对应该注解：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package beijing.huanghuan.anotations.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Service;

import java.lang.reflect.Field;

/**
 * 对String或者Entity中的String进行AntiXSS处理
 * &amp;lt;p/&amp;gt;
 * Created by huanghuan on 16/5/21.
 */
@Service
@Aspect
public class AntiXSSAspect {

    /**
     * 定义切面，定位到@AntiXSS注解的地方
     */
    @Pointcut(&quot;@annotation(beijing.huanghuan.anotations.AntiXSS)&quot;)
    public void antiXSSPointCut() {

    }

    /**
     * 对String类型或包含String类型的Entity进行antiXSS处理
     *
     * @param point
     */
    @Around(&quot;antiXSSPointCut()&quot;)
    public Object doAround(ProceedingJoinPoint point) {
        Object result = null;
        Object args[] = point.getArgs();
        try {
            antiXSS(args);
            result = point.proceed(args);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        return result;
    }

    /**
     * antiXSS处理
     *
     * @param args
     */
    private void antiXSS(Object[] args) {
        if (args == null) {
            return;
        }
        for (int i = 0; i &amp;lt; args.length; i++) {
            if (args[i] == null) {
                continue;
            }
            if (args[i] instanceof String) {
                args[i] = antiXSS((String) args[i]);
            }
            if (!isPrimitive(args[i])) {
                args[i] = antiXSSEntity(args[i]);
            }
        }
    }

    /**
     * 对Entity进行antiXSS
     *
     * @param object
     * @return 处理后的结果
     */
    private Object antiXSSEntity(Object object) {
        Field[] fields = object.getClass().getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(true);
            try {
                Object arg = field.get(object);
                if (arg instanceof String) {
                    arg = antiXSS((String) arg);
                    field.set(object, arg);
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        return object;
    }

    /**
     * 判断是否是基本类型
     *
     * @param arg
     * @return
     */
    private boolean isPrimitive(Object arg) {
        try {
            /************ 基本类型中包含Class&amp;lt;T&amp;gt; TYPE字段 **********/
            Field field = arg.getClass().getDeclaredField(&quot;TYPE&quot;);
            field.setAccessible(true);
            Class fieldClass = (Class) field.get(arg);
            if (fieldClass.isPrimitive()) {
                return true;
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }

    /**
     * antiXSS实现
     *
     * @param target
     * @return
     */
    private String antiXSS(String target) {
        /********* 自己的antiXSS或其它实现 **********/
        return target + &quot;(antiXSS success)&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这部分代码中&lt;code class=&quot;highlighter-rouge&quot;&gt;@PointCut&lt;/code&gt;定义了其作用的位置是&lt;code class=&quot;highlighter-rouge&quot;&gt;AntiXSS&lt;/code&gt;注解的方法，而&lt;code class=&quot;highlighter-rouge&quot;&gt;@Around&lt;/code&gt;来进行参数处理，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ProceedingJoinPoint&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;getArgs&lt;/code&gt;即可获得所有的入参数，进行处理后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;proceed(args[])&lt;/code&gt;传回。&lt;/p&gt;

&lt;p&gt;在处理的过程中，由于我们只需要对&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;类型的域进行处理，对于本来就是基本类型的域，可以直接通过&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof String&lt;/code&gt;进行判定，而对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Entity&lt;/code&gt;这种&lt;code class=&quot;highlighter-rouge&quot;&gt;POJO&lt;/code&gt;类型的对象，我们需要一些其它的方法，来首现判定出它不是基本类型，然后再分析出其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; Filed i.e. 反射:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getClass().getDeclaredFields()&lt;/code&gt;获取对象中的所有Field，并将它们的访问权限设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;对每一个Field，获取其中的名为&lt;code class=&quot;highlighter-rouge&quot;&gt;TYPE&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;，这其实是一个取巧的方法，之所以这么做是因为基本类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;wrapper&lt;/code&gt;里都一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&amp;lt;T&amp;gt; TYPE&lt;/code&gt;字段，通过该字段能够判定它是不是基本类型，而普通的与数据库对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;Entity&lt;/code&gt;自然是不会有这中种字段的。&lt;/li&gt;
  &lt;li&gt;然后将该Field转化为Class，并通过Class的&lt;code class=&quot;highlighter-rouge&quot;&gt;isPrimitive&lt;/code&gt;方法来判定是否为基本类型，期间出现任何异常则表示该对象不是基本类型&lt;/li&gt;
  &lt;li&gt;当判定出该对象是&lt;code class=&quot;highlighter-rouge&quot;&gt;Entity&lt;/code&gt;，则获取其中的所有Field，按照之前的思路进行处理。注意，上面的代码只支持包含基本类型的Entity，对于像&lt;code class=&quot;highlighter-rouge&quot;&gt;hibernate&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;many to one&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;one to many&lt;/code&gt;的判定，还需要读者自己去实现。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里补充&lt;code class=&quot;highlighter-rouge&quot;&gt;Double&lt;/code&gt;源码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;字段定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * The {@code Class} instance representing the primitive type
 * {@code double}.
 *
 * @since JDK1.1
 */
public static final Class&amp;lt;Double&amp;gt; TYPE=(Class&amp;lt;Double&amp;gt;)Class.getPrimitiveClass(&quot;double&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;测试用的&lt;code class=&quot;highlighter-rouge&quot;&gt;TestAntiXSSDaoImpl&lt;/code&gt;类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by huanghuan on 16/5/21.
 */
@Repository
public class TestAntiXSSDaoImpl {

    @AntiXSS
    public void testSave(long id, String text) {
        System.out.println(&quot;id: &quot; + id + &quot; text: &quot; + text);
    }

    @AntiXSS
    public void testSaveObject(Object object) {
        System.out.println(object.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试类&lt;code class=&quot;highlighter-rouge&quot;&gt;AntiXSSAspectTest&lt;/code&gt;类,&lt;code class=&quot;highlighter-rouge&quot;&gt;@Data&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Lombok&lt;/code&gt;注解，自动生成&lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by huanghuan on 16/5/21.
 */
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(Starter.class)
public class AntiXSSAspectTest {

    @Autowired
    private TestAntiXSSDaoImpl testAntiXSSDao;

    @Test
    public void testAntiXSS() {
        testAntiXSSDao.testSave(1, &quot;test save string&quot;);
        testAntiXSSDao.testSaveObject(new TestEntity());
    }

    public
    @Data
    class TestEntity {
        long id = 2;
        String text = &quot;test save Object&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id:1 text: test save string(antiXSS success)
AntiXSSAspectTest.TestEntity(id=2, text=test save Object(antiXSS success))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;成功的进行的处理，至于&lt;code class=&quot;highlighter-rouge&quot;&gt;antiXSS&lt;/code&gt;的具体实现请自己补充。&lt;/p&gt;
</description>
        <pubDate>Sat, 21 May 2016 12:59:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/linux/2016/05/21/AOP%E4%B9%8BantiXSS.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/linux/2016/05/21/AOP%E4%B9%8BantiXSS.html</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>程序小事</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jekyll-github&quot; id=&quot;markdown-toc-jekyll-github&quot;&gt;1. jekyll github发布问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;2. 准备的技能树&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;3. 今后工作状态&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#macsed&quot; id=&quot;markdown-toc-macsed&quot;&gt;4. Mac下sed问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;5. 为博客添加目录&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rescuetime&quot; id=&quot;markdown-toc-rescuetime&quot;&gt;6. 尝试使用rescuetime&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;7. 工作入职(2015-04-04)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;8. 博客迁移计划(2015-5-12)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jekyll-github&quot;&gt;1. jekyll github发布问题&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;时间：2016年2月8日 晚&lt;/li&gt;
  &lt;li&gt;问题回放：在本地发布无问题的jekyll博客，在&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;到github上时迟迟不能显示。但如果把博客的创建时间设置为今天之前，则发布成功。&lt;/li&gt;
  &lt;li&gt;问题分析：目前还没有找到发生该问题的原因，不知道是否是因为github pages本身有这样的设置，正在调查中。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;jekyll博客的搭建和发布可参考:&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&quot;&gt;阮一峰的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;解答 2016年2月23日&lt;/h4&gt;
&lt;p&gt;github应该采用的是utc时间，只需要将博客的&lt;code class=&quot;highlighter-rouge&quot;&gt;yaml&lt;/code&gt;信息头中的	&lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt;参数进行时区设置，如果作者使用的是北京时间，则设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;+0800&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2. 准备的技能树&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;redis&lt;/li&gt;
  &lt;li&gt;zookeeper&lt;/li&gt;
  &lt;li&gt;spring(需要进阶)&lt;/li&gt;
  &lt;li&gt;rest&lt;/li&gt;
  &lt;li&gt;数据库(从mysql入手)&lt;/li&gt;
  &lt;li&gt;脚本&lt;/li&gt;
  &lt;li&gt;算法(需要进阶)&lt;/li&gt;
  &lt;li&gt;网络&lt;/li&gt;
  &lt;li&gt;javascript&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3. 今后工作状态&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在工作中游刃有余，同时保持对新技术的兴趣和尝试，参与到产品的设计和策划中。&lt;/li&gt;
  &lt;li&gt;未来事不可预知，不要过多的担忧，多思无益&lt;/li&gt;
  &lt;li&gt;不可能每次遇到问题都已做好准备，要冷静的去思考解决之法&lt;/li&gt;
  &lt;li&gt;谦虚而脚踏实地，与志同道合的人称为朋友，不要为不合的人烦扰&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;macsed&quot;&gt;4. Mac下sed问题&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sed -i &#39;&#39; &#39;1a test&#39; test&lt;/code&gt;时如果是&lt;code class=&quot;highlighter-rouge&quot;&gt;1a&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;1i&lt;/code&gt;都会报错，这应该是Mac自带的&lt;code class=&quot;highlighter-rouge&quot;&gt;sed&lt;/code&gt;问题，所以选择&lt;code class=&quot;highlighter-rouge&quot;&gt;brew install gnu-sed&lt;/code&gt;来替换掉，改用&lt;code class=&quot;highlighter-rouge&quot;&gt;gsed&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;5. 为博客添加目录&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gsed -i &#39;6a *内容目录\n{:toc}\n&#39; *.md&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;rescuetime&quot;&gt;6. 尝试使用rescuetime&lt;/h2&gt;

&lt;p&gt;时间管理应该是以后工作很重要的内容，尝试使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rescuetime&lt;/code&gt;来管理时间，之后可以对比下和番茄工作法的区别。&lt;/p&gt;

&lt;p&gt;2015-5-12日：使用了一段rescuetime后，发现意义并不是很大，可能我目前所在的是一个纯粹的开发的阶段，每天的时间都在开发代码，rescuetime显示的效率都在87％左右。这个工具只能看到我是否在专心工作，并不能衡量工作的效率。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;7. 工作入职(2015-04-04)&lt;/h2&gt;

&lt;p&gt;这是入职的第三天，周围的同事给我感觉挺不错，在这个部门相信我能学到不少东西，加油吧少年，Be simple !&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;8. 博客迁移计划(2015-5-12)&lt;/h2&gt;

&lt;p&gt;最近刚开始工作，没怎么写博客了，现在工作的内容开始熟悉了，准备针对工作中的问题和学到的东西进行定期的总结。&lt;br /&gt;
博客准备进行一下改版，&lt;a href=&quot;http://novoland.github.io/index.html&quot;&gt;novoland的博客&lt;/a&gt;风格很不错，准备照着他的改版。&lt;/p&gt;
</description>
        <pubDate>Thu, 12 May 2016 22:53:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/develop/2016/05/12/%E7%A8%8B%E5%BA%8F%E5%B0%8F%E4%BA%8B.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/develop/2016/05/12/%E7%A8%8B%E5%BA%8F%E5%B0%8F%E4%BA%8B.html</guid>
        
        
        <category>Develop</category>
        
      </item>
    
      <item>
        <title>读书笔记-学</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#effective-java&quot; id=&quot;markdown-toc-effective-java&quot;&gt;1. Effective Java&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#spring-in-action&quot; id=&quot;markdown-toc-spring-in-action&quot;&gt;2. Spring in action&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;effective-java&quot;&gt;1. Effective Java&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;By Joshua Bloch&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/effective_java.jpg&quot; alt=&quot;Effective Java&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正在学习&lt;/p&gt;

&lt;h2 id=&quot;spring-in-action&quot;&gt;2. Spring in action&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;By Craig Walls&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/springinaction.jpg&quot; alt=&quot;Spring in action&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这本书紧紧围绕着&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;，在工作中能设计到的&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;实用技术基本都有讲解，并不涉及&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;的原理，对于工作上的&lt;code class=&quot;highlighter-rouge&quot;&gt;Spring&lt;/code&gt;使用恰好合适。&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Apr 2016 20:57:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/read/2016/04/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%AD%A6.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/read/2016/04/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%AD%A6.html</guid>
        
        
        <category>Read</category>
        
      </item>
    
      <item>
        <title>Mac高效开发小技能</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#pushddir&quot; id=&quot;markdown-toc-pushddir&quot;&gt;1. pushd和dir命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ctrlr&quot; id=&quot;markdown-toc-ctrlr&quot;&gt;2. CTRL+R&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#iterm2&quot; id=&quot;markdown-toc-iterm2&quot;&gt;3. Iterm2分屏&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#keycue&quot; id=&quot;markdown-toc-keycue&quot;&gt;4. KeyCue&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#spectacle&quot; id=&quot;markdown-toc-spectacle&quot;&gt;5. Spectacle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;系统是：MacOS&lt;br /&gt;
本文主要记录一些我在工作中掌握的能提高效率的小技能。&lt;/p&gt;

&lt;h3 id=&quot;pushddir&quot;&gt;1. pushd和dir命令&lt;/h3&gt;

&lt;p&gt;在Mac或者Linux环境下，切换目录是个非常麻烦的事情，为了提高这个过程的效率，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;pushd&lt;/code&gt;命令。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;pushd与dir：&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/pushd.png&quot; alt=&quot;pushd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，&lt;code class=&quot;highlighter-rouge&quot;&gt;pushd&lt;/code&gt;命令能够在&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt;到某个目录下的同时，将该目录保存。保存的目录可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dirs -v&lt;/code&gt;查看，下次要切换到一个目录的时候，可以直接&lt;code class=&quot;highlighter-rouge&quot;&gt;pushd +&amp;lt;对应编号&amp;gt;&lt;/code&gt;，非常的方便。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;cd -命令&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;相对更简单点的是&lt;code class=&quot;highlighter-rouge&quot;&gt;cd -&lt;/code&gt;命令，它能直接返回之前所在的目录，其效果如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/cd.png&quot; alt=&quot;cd&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ctrlr&quot;&gt;2. CTRL+R&lt;/h3&gt;

&lt;p&gt;这个真是超级实用，可以搜索已经使用过的命令，如果没找到，再&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+R&lt;/code&gt;到下一个匹配的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/ctrlr.png&quot; alt=&quot;ctrl+r&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;iterm2&quot;&gt;3. Iterm2分屏&lt;/h3&gt;

&lt;p&gt;之前用过&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux&lt;/code&gt;的切分屏幕，如果是在一个Linux环境下，还比较实用（但公司的机器装&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux&lt;/code&gt;之类的比较麻烦，&lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt;之类的有时不让用，而且也不能每台机器都去装）。所以其实不如用Iterm2的分屏，&lt;code class=&quot;highlighter-rouge&quot;&gt;Command+D&lt;/code&gt;是垂直分割，&lt;code class=&quot;highlighter-rouge&quot;&gt;Command+Shift+D&lt;/code&gt;是水平分割，然后多连几次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/cmdd.png&quot; alt=&quot;cmd+d&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;keycue&quot;&gt;4. KeyCue&lt;/h3&gt;

&lt;p&gt;KeyCue可以用来显示当前软件的快捷键，长按&lt;code class=&quot;highlighter-rouge&quot;&gt;Command&lt;/code&gt;健即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/keycue.png&quot; alt=&quot;keycue&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;spectacle&quot;&gt;5. Spectacle&lt;/h3&gt;

&lt;p&gt;相信工作的时候程序员都不只一个屏幕，我目前就是一台Mac接两台显示器，显示器多了把软件拖来拖去很不方便，还要调显示的大小更浪费时间，Spectacle通过几个快捷键就能帮我们解决这个问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/spectacle.png&quot; alt=&quot;spectacle&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+option+command+&amp;lt;方向键&amp;gt;&lt;/code&gt;就能把当前软件丢到另一个屏幕上，然后再用快捷键调显示比例，两下搞定。&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Apr 2016 22:14:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/linux/2016/04/17/Linux%E5%B7%A5%E4%BD%9C.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/linux/2016/04/17/Linux%E5%B7%A5%E4%BD%9C.html</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>边边角角的知识点</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#setuid&quot; id=&quot;markdown-toc-setuid&quot;&gt;1. setuid权限&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;2. 执行权限&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;3. 标准输出与错误输出&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;4. 重定向&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;5. Java方法签名&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#flash-cookie&quot; id=&quot;markdown-toc-flash-cookie&quot;&gt;6. flash cookie&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#su--su&quot; id=&quot;markdown-toc-su--su&quot;&gt;7. su -与su的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;setuid&quot;&gt;1. setuid权限&lt;/h2&gt;

&lt;p&gt;今天调了一下Iterm2中&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;的配色，发现在&lt;code class=&quot;highlighter-rouge&quot;&gt;\bin&lt;/code&gt;目录下有如图的显示效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/setuid_1.png&quot; alt=&quot;setuid&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ps和rcp的执行文件颜色和其它不同，从&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -lha&lt;/code&gt;的结果来看它们两个与其它文件并没有什么不同，于是我再用&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;命令查看文件：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/setuid_2.png&quot; alt=&quot;setuid_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时发现ps和rcp的前面多了个&lt;code class=&quot;highlighter-rouge&quot;&gt;setuid&lt;/code&gt;的参数，该参数是Linux的三个特殊权限之一，其作用是让执行该命令的用户拥有所有者的权限。除了&lt;code class=&quot;highlighter-rouge&quot;&gt;setuid&lt;/code&gt;外还有&lt;code class=&quot;highlighter-rouge&quot;&gt;setgid&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;stick bit&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2. 执行权限&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/execute.png&quot; alt=&quot;execute&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，作为execute.sh的owner，我拥有&lt;code class=&quot;highlighter-rouge&quot;&gt;rw&lt;/code&gt;读写权限，但如果想通过&lt;code class=&quot;highlighter-rouge&quot;&gt;./execute.sh&lt;/code&gt;直接执行，却被告知权限不够，而用&lt;code class=&quot;highlighter-rouge&quot;&gt;sh execute.sh&lt;/code&gt;却能够执行。后者实际上是将脚本交由&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/sh&lt;/code&gt;执行，仅仅需要读权限即可。那么如果我只有&lt;code class=&quot;highlighter-rouge&quot;&gt;execute.sh&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;执行权限，是否能够直接执行了？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/execute_x.png&quot; alt=&quot;execute_x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，仅仅拥有执行权限或仅拥有读权限，都不能直接执行&lt;code class=&quot;highlighter-rouge&quot;&gt;execute.sh&lt;/code&gt;，只有当两种权限同时具备时才可。我的理解是，执行权限控制文件是否可直接执行，而由于该文件亦需要&lt;code class=&quot;highlighter-rouge&quot;&gt;\bin\sh&lt;/code&gt;程序去读取并解释执行，所以同时亦需要读权限。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3. 标准输出与错误输出&lt;/h2&gt;

&lt;p&gt;在Shell脚本中有时能看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt;这样的语句，在语句中&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;/dev/null&lt;/code&gt;等同于&lt;code class=&quot;highlighter-rouge&quot;&gt;1&amp;gt;/dev/null&lt;/code&gt;，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;表示&lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;标准输出，而&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/null&lt;/code&gt;表示空设备文件。默认的标准输出和标准错误输出都是打印在屏幕上，&lt;code class=&quot;highlighter-rouge&quot;&gt;1&amp;gt;/dev/null&lt;/code&gt;则表示不输出任何信息到终端，也不定向到系统文件中。而&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;表示标准错误输出，而&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;表示等同于的意思，&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;则表示为标准错误输出的重定向等同于标准输出，整条语句的意思实际傻姑娘就是不输出任何内容。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;4. 重定向&lt;/h2&gt;
&lt;p&gt;在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;重定向时，会先判断右边文件是否存在，存在则先删除，不存在则创建。因此，&lt;code class=&quot;highlighter-rouge&quot;&gt;cat test &amp;gt; test&lt;/code&gt;这样的操作，结果永远为空。&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;5. Java方法签名&lt;/h2&gt;

&lt;p&gt;方法签名：返回值内行＋方法名＋参数列表，参数列表受到参数的顺序，类型，数量的影响，&lt;code class=&quot;highlighter-rouge&quot;&gt;public void test(int a,long b)&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;public void test(long a,int b)&lt;/code&gt;签名不同。&lt;/p&gt;

&lt;h2 id=&quot;flash-cookie&quot;&gt;6. flash cookie&lt;/h2&gt;

&lt;p&gt;flash cookie用于记录用户在浏览flash网页时保留信息，它比http cookie的容量更大，没有默认过期时间且难以删除。flash cookie容易被用来窃取普通用户的信息，且难以预防，这点需要注意。&lt;/p&gt;

&lt;p&gt;ps：第三方如何盗取用户cookies？ 可以通过在广告位中植入代码，获取原网站给用户种下的cookies&lt;/p&gt;

&lt;h2 id=&quot;su--su&quot;&gt;7. su -与su的区别&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;su - USERNAME&lt;/code&gt;切换用户后，工作环境同时也切换&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;su USERNAME&lt;/code&gt; 切换后不改变原用户的工作目录和环境变量目录&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Apr 2016 15:41:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/pieces/2016/04/15/%E8%BE%B9%E8%BE%B9%E8%A7%92%E8%A7%92%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/pieces/2016/04/15/%E8%BE%B9%E8%BE%B9%E8%A7%92%E8%A7%92%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9.html</guid>
        
        
        <category>Pieces</category>
        
      </item>
    
      <item>
        <title>算法导论学习</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;算法导论学习&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;算法基础&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;插入排序&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;分治策略&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;最大连续子数组和&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;算法导论学习&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;之前的算法学习更多的是为面试准备，具有很强的目的性。现在的出发点是进一步理解和掌握基本的算法，并静下心来领会算法中思考和解决问题的方式，书中复杂度部分的学习暂时略过。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;主要学习资料：&lt;a href=&quot;http://open.163.com/special/opencourse/algorithms.html&quot;&gt;算法导论 第三版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/sadwxqezc/Algorithms.git&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;算法基础&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;算法是解决问题的步骤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;插入排序&lt;/h3&gt;

&lt;p&gt;《算法导论》中对插入排序举了一个非常恰当的列子：大家斗地主时，边摸牌边对手中的牌排序，这实际上就是一个插入排序的过程，保证手中的牌始终是有序的。&lt;/p&gt;

&lt;p&gt;将如我们要对数组&lt;code class=&quot;highlighter-rouge&quot;&gt;[1,3,7,-1,11,2,23,0,1]&lt;/code&gt;排序，要求结果为升序，用插入排序的写法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void myInsertSort(int[] sequence) {
    for (int j = 1; j &amp;lt; sequence.length; j++) {
        int i = 0;
        int temp = sequence[j];
        while (i &amp;lt; j &amp;amp;&amp;amp; sequence[i] &amp;lt; temp) {
            i++;
        }
        for (int k = j; k &amp;gt; i; k--) {
            sequence[k] = sequence[k - 1];
        }
        sequence[i] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我的做法是从前往后找插入位置，而书中的做法是从后往前找，其写法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void bookInsertSort(int[] sequence) {
    for (int j = 1; j &amp;lt; sequence.length; j++) {
        int temp = sequence[j];
        int i = j - 1;
        while (i &amp;gt; 0 &amp;amp;&amp;amp; sequence[i] &amp;gt; temp) {
            sequence[i + 1] = sequence[i];
            i--;
        }
        sequence[i + 1] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;两者时间性能差别不大，书上的写法显得更加简洁。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;分治策略&lt;/h2&gt;

&lt;p&gt;分治策略(Divide and Conquer)寻求的是递归的求解子问题，把规模大的问题分解成规模更小的问题去解决，在每个递归中有如下三个步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分解(Divide)：将问题划分为规模更小的子问题，问题的本质与原问题一致&lt;/li&gt;
  &lt;li&gt;解决(Conquer)：递归的求解出子问题，如果子问题的规模已经足够小，则停止递归，求解并返回具体值&lt;/li&gt;
  &lt;li&gt;合并(Combine)：步骤将子问题的解组合成原问题的解&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分治的方法往往可以用递归式子来表示，能写出递归式，问题基本就已经解决了，剩下的就是敲出代码，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;Merge Sort&lt;/code&gt;的递归式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;T(n)=O(1) (n=1)
T(n)=2T(n/2)+O(n) (n&amp;gt;1)
求解可得T(n)=O(nlgn)，即为归并排序的时间复杂度
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;最大连续子数组和&lt;/h3&gt;
&lt;h4&gt;问题描述：&lt;/h4&gt;
&lt;p&gt;求数组&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;13,-3,-25,20,-3,-16,-23,18,20,-7,12,-5,-22,15,-4,7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;的和最大的最大连续子数组。&lt;/p&gt;

&lt;h4&gt;解法一：暴力搜索&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static void violentSearch(int[] array) {
    int maxSum = 0;
    for (int i = 0; i &amp;lt; array.length; i++) {
        int temp = 0;
        for (int j = i; j &amp;lt; array.length; j++) {
            temp += array[j];
            if (temp &amp;gt; maxSum) {
                maxSum = temp;
            }
        }
    }
    System.out.println(&quot;maxSum:&quot; + maxSum);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果是43，很明显这是一种时间复杂度较高的做法。&lt;/p&gt;

&lt;h4&gt;解法二：分治策略&lt;/h4&gt;

&lt;p&gt;运用分治策略的话，我们可以把数组中分，然后问题变为，求左子数组的最大连续和，右子数组的最大连续和，以及跨越中分点的最大连续后，然后求出三者中的最大值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static int divideAndConquer(int[] array, int start, int end) {
    if (start == end) {
        return array[start];
    } else {
        int mid = (start + end) / 2;
        int max_right = divideAndConquer(array, mid + 1, end);
        int max_left = max_right;
        if (start &amp;lt; mid - 1) {
            max_left = divideAndConquer(array, start, mid - 1);
        }
        int max_mid = findMaxCrossingMid(array, start, mid, end);
        if (max_left &amp;lt; max_right) {
            max_left = max_right;
        }
        if (max_left &amp;lt; max_mid) {
            max_left = max_mid;
        }
        return max_left;
    }
}

private static int findMaxCrossingMid(int[] array, int start, int mid, int end) {
    int result = array[mid];
    int left = findMaxBackward(array, mid - 1, start);
    int right = findMaxForward(array, mid + 1, end);
    if (left &amp;gt; 0) {
        result += left;
    }
    if (right &amp;gt; 0) {
        result += right;
    }
    return result;
}

private static int findMaxForward(int[] array, int start, int end) {
    if (start &amp;gt; end) {
        return 0;
    }
    int sum = array[start];
    int max = array[start];
    for (int i = start + 1; i &amp;lt;= end; i++) {
        sum += array[i];
        if (sum &amp;gt; max) {
            max = sum;
        }
    }
    return max;
}

private static int findMaxBackward(int[] array, int start, int end) {
    if (start &amp;lt; end) {
        return 0;
    }
    int sum = array[start];
    int max = array[start];
    for (int i = start - 1; i &amp;gt;= end; i--) {
        sum += array[i];
        if (sum &amp;gt; max) {
            max = sum;
        }
    }
    return max;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果为43，与书上不同，这里我专门写了&lt;code class=&quot;highlighter-rouge&quot;&gt;findMaxForward()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;findMaxBackWard()&lt;/code&gt;两个小方法，虽然导致代码较长，但我个人认为这样的写法更加清晰，出了问题好发现。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Apr 2016 20:00:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/algorithm/2016/04/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/algorithm/2016/04/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93.html</guid>
        
        
        <category>Algorithm</category>
        
      </item>
    
  </channel>
</rss>
