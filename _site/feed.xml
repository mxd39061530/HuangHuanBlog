<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>黄欢的博客</title>
    <description>黄欢的博客：程序，读书，电影</description>
    <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/</link>
    <atom:link href="http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 17 Apr 2016 22:49:56 +0800</pubDate>
    <lastBuildDate>Sun, 17 Apr 2016 22:49:56 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Mac高效开发小技能</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#pushddir&quot; id=&quot;markdown-toc-pushddir&quot;&gt;1. pushd和dir命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ctrlr&quot; id=&quot;markdown-toc-ctrlr&quot;&gt;2. CTRL+R&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#iterm2&quot; id=&quot;markdown-toc-iterm2&quot;&gt;3. Iterm2分屏&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#keycue&quot; id=&quot;markdown-toc-keycue&quot;&gt;4. KeyCue&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#spectacle&quot; id=&quot;markdown-toc-spectacle&quot;&gt;5. Spectacle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;系统是：MacOS&lt;br /&gt;
本文主要记录一些我在工作中掌握的能提高效率的小技能。&lt;/p&gt;

&lt;h3 id=&quot;pushddir&quot;&gt;1. pushd和dir命令&lt;/h3&gt;

&lt;p&gt;在Mac或者Linux环境下，切换目录是个非常麻烦的事情，为了提高这个过程的效率，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;pushd&lt;/code&gt;命令。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;pushd与dir：&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/pushd.png&quot; alt=&quot;pushd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，&lt;code class=&quot;highlighter-rouge&quot;&gt;pushd&lt;/code&gt;命令能够在&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt;到某个目录下的同时，将该目录保存。保存的目录可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dirs -v&lt;/code&gt;查看，下次要切换到一个目录的时候，可以直接&lt;code class=&quot;highlighter-rouge&quot;&gt;pushd +&amp;lt;对应编号&amp;gt;&lt;/code&gt;，非常的方便。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;cd -命令&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;相对更简单点的是&lt;code class=&quot;highlighter-rouge&quot;&gt;cd -&lt;/code&gt;命令，它能直接返回之前所在的目录，其效果如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/cd.png&quot; alt=&quot;cd&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ctrlr&quot;&gt;2. CTRL+R&lt;/h3&gt;

&lt;p&gt;这个真是超级实用，可以搜索已经使用过的命令，如果没找到，再&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+R&lt;/code&gt;到下一个匹配的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/ctrlr.png&quot; alt=&quot;ctrl+r&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;iterm2&quot;&gt;3. Iterm2分屏&lt;/h3&gt;

&lt;p&gt;之前用过&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux&lt;/code&gt;的切分屏幕，如果是在一个Linux环境下，还比较实用（但公司的机器装&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux&lt;/code&gt;之类的比较麻烦，&lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt;之类的有时不让用，而且也不能每台机器都去装）。所以其实不如用Iterm2的分屏，&lt;code class=&quot;highlighter-rouge&quot;&gt;Command+D&lt;/code&gt;是垂直分割，&lt;code class=&quot;highlighter-rouge&quot;&gt;Command+Shift+D&lt;/code&gt;是水平分割，然后多连几次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/cmdd.png&quot; alt=&quot;cmd+d&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;keycue&quot;&gt;4. KeyCue&lt;/h3&gt;

&lt;p&gt;KeyCue可以用来显示当前软件的快捷键，长按&lt;code class=&quot;highlighter-rouge&quot;&gt;Command&lt;/code&gt;健即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/keycue.png&quot; alt=&quot;keycue&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;spectacle&quot;&gt;5. Spectacle&lt;/h3&gt;

&lt;p&gt;相信工作的时候程序员都不只一个屏幕，我目前就是一台Mac接两台显示器，显示器多了把软件拖来拖去很不方便，还要调显示的大小更浪费时间，Spectacle通过几个快捷键就能帮我们解决这个问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/spectacle.png&quot; alt=&quot;spectacle&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+option+command+&amp;lt;方向键&amp;gt;&lt;/code&gt;就能把当前软件丢到另一个屏幕上，然后再用快捷键调显示比例，两下搞定。&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Apr 2016 22:14:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/linux/2016/04/17/Linux%E5%B7%A5%E4%BD%9C.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/linux/2016/04/17/Linux%E5%B7%A5%E4%BD%9C.html</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>边边角角的知识点</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#setuid&quot; id=&quot;markdown-toc-setuid&quot;&gt;1. setuid权限&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;2. 执行权限&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;3. 标准输出与错误输出&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;4. 重定向&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;5. Java方法签名&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#flash-cookie&quot; id=&quot;markdown-toc-flash-cookie&quot;&gt;6. flash cookie&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#su--su&quot; id=&quot;markdown-toc-su--su&quot;&gt;7. su -与su的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;setuid&quot;&gt;1. setuid权限&lt;/h2&gt;

&lt;p&gt;今天调了一下Iterm2中&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;的配色，发现在&lt;code class=&quot;highlighter-rouge&quot;&gt;\bin&lt;/code&gt;目录下有如图的显示效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/setuid_1.png&quot; alt=&quot;setuid&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ps和rcp的执行文件颜色和其它不同，从&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -lha&lt;/code&gt;的结果来看它们两个与其它文件并没有什么不同，于是我再用&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;命令查看文件：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/setuid_2.png&quot; alt=&quot;setuid_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时发现ps和rcp的前面多了个&lt;code class=&quot;highlighter-rouge&quot;&gt;setuid&lt;/code&gt;的参数，该参数是Linux的三个特殊权限之一，其作用是让执行该命令的用户拥有所有者的权限。除了&lt;code class=&quot;highlighter-rouge&quot;&gt;setuid&lt;/code&gt;外还有&lt;code class=&quot;highlighter-rouge&quot;&gt;setgid&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;stick bit&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2. 执行权限&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/execute.png&quot; alt=&quot;execute&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，作为execute.sh的owner，我拥有&lt;code class=&quot;highlighter-rouge&quot;&gt;rw&lt;/code&gt;读写权限，但如果想通过&lt;code class=&quot;highlighter-rouge&quot;&gt;./execute.sh&lt;/code&gt;直接执行，却被告知权限不够，而用&lt;code class=&quot;highlighter-rouge&quot;&gt;sh execute.sh&lt;/code&gt;却能够执行。后者实际上是将脚本交由&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/sh&lt;/code&gt;执行，仅仅需要读权限即可。那么如果我只有&lt;code class=&quot;highlighter-rouge&quot;&gt;execute.sh&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;执行权限，是否能够直接执行了？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/execute_x.png&quot; alt=&quot;execute_x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，仅仅拥有执行权限或仅拥有读权限，都不能直接执行&lt;code class=&quot;highlighter-rouge&quot;&gt;execute.sh&lt;/code&gt;，只有当两种权限同时具备时才可。我的理解是，执行权限控制文件是否可直接执行，而由于该文件亦需要&lt;code class=&quot;highlighter-rouge&quot;&gt;\bin\sh&lt;/code&gt;程序去读取并解释执行，所以同时亦需要读权限。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3. 标准输出与错误输出&lt;/h2&gt;

&lt;p&gt;在Shell脚本中有时能看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt;这样的语句，在语句中&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;/dev/null&lt;/code&gt;等同于&lt;code class=&quot;highlighter-rouge&quot;&gt;1&amp;gt;/dev/null&lt;/code&gt;，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;表示&lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;标准输出，而&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/null&lt;/code&gt;表示空设备文件。默认的标准输出和标准错误输出都是打印在屏幕上，&lt;code class=&quot;highlighter-rouge&quot;&gt;1&amp;gt;/dev/null&lt;/code&gt;则表示不输出任何信息到终端，也不定向到系统文件中。而&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;表示标准错误输出，而&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;表示等同于的意思，&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;则表示为标准错误输出的重定向等同于标准输出，整条语句的意思实际傻姑娘就是不输出任何内容。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;4. 重定向&lt;/h2&gt;
&lt;p&gt;在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;重定向时，会先判断右边文件是否存在，存在则先删除，不存在则创建。因此，&lt;code class=&quot;highlighter-rouge&quot;&gt;cat test &amp;gt; test&lt;/code&gt;这样的操作，结果永远为空。&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;5. Java方法签名&lt;/h2&gt;

&lt;p&gt;方法签名：返回值内行＋方法名＋参数列表，参数列表受到参数的顺序，类型，数量的影响，&lt;code class=&quot;highlighter-rouge&quot;&gt;public void test(int a,long b)&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;public void test(long a,int b)&lt;/code&gt;签名不同。&lt;/p&gt;

&lt;h2 id=&quot;flash-cookie&quot;&gt;6. flash cookie&lt;/h2&gt;

&lt;p&gt;flash cookie用于记录用户在浏览flash网页时保留信息，它比http cookie的容量更大，没有默认过期时间且难以删除。flash cookie容易被用来窃取普通用户的信息，且难以预防，这点需要注意。&lt;/p&gt;

&lt;p&gt;ps：第三方如何盗取用户cookies？ 可以通过在广告位中植入代码，获取原网站给用户种下的cookies&lt;/p&gt;

&lt;h2 id=&quot;su--su&quot;&gt;7. su -与su的区别&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;su - USERNAME&lt;/code&gt;切换用户后，工作环境同时也切换&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;su USERNAME&lt;/code&gt; 切换后不改变原用户的工作目录和环境变量目录&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Apr 2016 15:41:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/pieces/2016/04/15/%E8%BE%B9%E8%BE%B9%E8%A7%92%E8%A7%92%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/pieces/2016/04/15/%E8%BE%B9%E8%BE%B9%E8%A7%92%E8%A7%92%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9.html</guid>
        
        
        <category>Pieces</category>
        
      </item>
    
      <item>
        <title>读书笔记-学</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#effective-java&quot; id=&quot;markdown-toc-effective-java&quot;&gt;1. Effective Java&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java-restful-web-service&quot; id=&quot;markdown-toc-java-restful-web-service&quot;&gt;2. Java RESTful Web Service实战&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;effective-java&quot;&gt;1. Effective Java&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;By Joshua Bloch&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/effective_java.jpg&quot; alt=&quot;Effective Java&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;java-restful-web-service&quot;&gt;2. Java RESTful Web Service实战&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;韩陆&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/java_restful.jpg&quot; alt=&quot;Java RESTful&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正在学习&lt;/p&gt;

</description>
        <pubDate>Sun, 10 Apr 2016 20:14:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/read/2016/04/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%AD%A6.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/read/2016/04/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%AD%A6.html</guid>
        
        
        <category>Read</category>
        
      </item>
    
      <item>
        <title>算法导论学习</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;算法导论学习&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;算法基础&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;插入排序&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;分治策略&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;最大连续子数组和&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;算法导论学习&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;之前的算法学习更多的是为面试准备，具有很强的目的性。现在的出发点是进一步理解和掌握基本的算法，并静下心来领会算法中思考和解决问题的方式，书中复杂度部分的学习暂时略过。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;主要学习资料：&lt;a href=&quot;http://open.163.com/special/opencourse/algorithms.html&quot;&gt;算法导论 第三版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/sadwxqezc/Algorithms.git&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;算法基础&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;算法是解决问题的步骤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;插入排序&lt;/h3&gt;

&lt;p&gt;《算法导论》中对插入排序举了一个非常恰当的列子：大家斗地主时，边摸牌边对手中的牌排序，这实际上就是一个插入排序的过程，保证手中的牌始终是有序的。&lt;/p&gt;

&lt;p&gt;将如我们要对数组&lt;code class=&quot;highlighter-rouge&quot;&gt;[1,3,7,-1,11,2,23,0,1]&lt;/code&gt;排序，要求结果为升序，用插入排序的写法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void myInsertSort(int[] sequence) {
    for (int j = 1; j &amp;lt; sequence.length; j++) {
        int i = 0;
        int temp = sequence[j];
        while (i &amp;lt; j &amp;amp;&amp;amp; sequence[i] &amp;lt; temp) {
            i++;
        }
        for (int k = j; k &amp;gt; i; k--) {
            sequence[k] = sequence[k - 1];
        }
        sequence[i] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我的做法是从前往后找插入位置，而书中的做法是从后往前找，其写法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void bookInsertSort(int[] sequence) {
    for (int j = 1; j &amp;lt; sequence.length; j++) {
        int temp = sequence[j];
        int i = j - 1;
        while (i &amp;gt; 0 &amp;amp;&amp;amp; sequence[i] &amp;gt; temp) {
            sequence[i + 1] = sequence[i];
            i--;
        }
        sequence[i + 1] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;两者时间性能差别不大，书上的写法显得更加简洁。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;分治策略&lt;/h2&gt;

&lt;p&gt;分治策略(Divide and Conquer)寻求的是递归的求解子问题，把规模大的问题分解成规模更小的问题去解决，在每个递归中有如下三个步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分解(Divide)：将问题划分为规模更小的子问题，问题的本质与原问题一致&lt;/li&gt;
  &lt;li&gt;解决(Conquer)：递归的求解出子问题，如果子问题的规模已经足够小，则停止递归，求解并返回具体值&lt;/li&gt;
  &lt;li&gt;合并(Combine)：步骤将子问题的解组合成原问题的解&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分治的方法往往可以用递归式子来表示，能写出递归式，问题基本就已经解决了，剩下的就是敲出代码，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;Merge Sort&lt;/code&gt;的递归式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;T(n)=O(1) (n=1)
T(n)=2T(n/2)+O(n) (n&amp;gt;1)
求解可得T(n)=O(nlgn)，即为归并排序的时间复杂度
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;最大连续子数组和&lt;/h3&gt;
&lt;h4&gt;问题描述：&lt;/h4&gt;
&lt;p&gt;求数组&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;13,-3,-25,20,-3,-16,-23,18,20,-7,12,-5,-22,15,-4,7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;的和最大的最大连续子数组。&lt;/p&gt;

&lt;h4&gt;解法一：暴力搜索&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static void violentSearch(int[] array) {
    int maxSum = 0;
    for (int i = 0; i &amp;lt; array.length; i++) {
        int temp = 0;
        for (int j = i; j &amp;lt; array.length; j++) {
            temp += array[j];
            if (temp &amp;gt; maxSum) {
                maxSum = temp;
            }
        }
    }
    System.out.println(&quot;maxSum:&quot; + maxSum);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果是43，很明显这是一种时间复杂度较高的做法。&lt;/p&gt;

&lt;h4&gt;解法二：分治策略&lt;/h4&gt;

&lt;p&gt;运用分治策略的话，我们可以把数组中分，然后问题变为，求左子数组的最大连续和，右子数组的最大连续和，以及跨越中分点的最大连续后，然后求出三者中的最大值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static int divideAndConquer(int[] array, int start, int end) {
    if (start == end) {
        return array[start];
    } else {
        int mid = (start + end) / 2;
        int max_right = divideAndConquer(array, mid + 1, end);
        int max_left = max_right;
        if (start &amp;lt; mid - 1) {
            max_left = divideAndConquer(array, start, mid - 1);
        }
        int max_mid = findMaxCrossingMid(array, start, mid, end);
        if (max_left &amp;lt; max_right) {
            max_left = max_right;
        }
        if (max_left &amp;lt; max_mid) {
            max_left = max_mid;
        }
        return max_left;
    }
}

private static int findMaxCrossingMid(int[] array, int start, int mid, int end) {
    int result = array[mid];
    int left = findMaxBackward(array, mid - 1, start);
    int right = findMaxForward(array, mid + 1, end);
    if (left &amp;gt; 0) {
        result += left;
    }
    if (right &amp;gt; 0) {
        result += right;
    }
    return result;
}

private static int findMaxForward(int[] array, int start, int end) {
    if (start &amp;gt; end) {
        return 0;
    }
    int sum = array[start];
    int max = array[start];
    for (int i = start + 1; i &amp;lt;= end; i++) {
        sum += array[i];
        if (sum &amp;gt; max) {
            max = sum;
        }
    }
    return max;
}

private static int findMaxBackward(int[] array, int start, int end) {
    if (start &amp;lt; end) {
        return 0;
    }
    int sum = array[start];
    int max = array[start];
    for (int i = start - 1; i &amp;gt;= end; i--) {
        sum += array[i];
        if (sum &amp;gt; max) {
            max = sum;
        }
    }
    return max;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果为43，与书上不同，这里我专门写了&lt;code class=&quot;highlighter-rouge&quot;&gt;findMaxForward()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;findMaxBackWard()&lt;/code&gt;两个小方法，虽然导致代码较长，但我个人认为这样的写法更加清晰，出了问题好发现。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Apr 2016 20:00:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/algorithm/2016/04/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/algorithm/2016/04/10/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93.html</guid>
        
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>读书笔记-思</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;1. 万历十五年&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#this-is-water&quot; id=&quot;markdown-toc-this-is-water&quot;&gt;2. This is Water&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;3. 看见&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;4. 最好的告别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 万历十五年&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;[美]黄仁宇著&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/wanli.jpg&quot; alt=&quot;万历十五年&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在看《万历十五年》之前，我先读完了整套《明朝那些事》，算是对整个明史有了一个全局的了解。《明朝那些事》算是在用网络小说的手法写历史，带入了较多作者个人的感情，每次人物总结会有一定的美化倾向，不够客观。但《明朝》这本书虽然不客观，却也不离谱，论述皆依据史实，同时文笔诙谐幽默，尤其对人物的描写着重笔墨，读起来通俗易懂，充满乐趣。因此，《明朝那些事》是文言文阅读能力有限的大众了解明史的较好途径，其中对于明朝政治，经济，军事等细节皆有描述，譬如“火耗”，“东林党”，&quot;心学&quot;等名词在其中有详尽的解释，能够大大降低阅读《万历十五年》的难度。&lt;/p&gt;

&lt;p&gt;万历十五年即为1587年，作者认为这一年为明朝历史的转折点，这个帝国从此走向灭亡。而我对本书的理解是，其作为转折点的原因有二：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;万历皇帝的怠政&lt;/li&gt;
  &lt;li&gt;国家的积弊：长期的以道德代替法律治理国家，以及文官治国发展到了一个顶峰，国家的体制已经凝固，难以改革。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然历史读起来会让人觉得事情都是理所当然的发生，但黄仁宇先生却以1587年为剖面，分析了人在其中的推动作用，这是尤为难得的贡献。而他在书中的分析也让人明白，即使人在历史中起了重大的推动作用，但该发生的事情却早晚必会发生。明朝的实际主人是文人阶层，底层人民受他们的统治。底层的人通过几代人的努力才有可能通过科举进入文人阶层，而文人阶层也只是为了维护国家的稳定，他们以道德约束这个有千万个农村构成的国家，却根本无心推动社会的发展。如此的社会循环所维持的时间能到达300年，之后则朝代更替再来一次。看历史总会有中悲凉的感觉，似乎所有的事情都是循环往复发生，有种宿命论的感觉。然而社会制度的变迁，其触发的源头却往往从技术的革新开始，而技术革新的本源来自于人们探索的精神。我想无论是制度，技术，主义，它们实际也只是人们探索的产物，而这种探索的精神为什么又只有人类才有，于其它地球生物上却并未看到。这样的精神是人先天就存在的，还是因为一些偶然和巧合正好赋予在人的身上了，这让我颇为费解。&lt;/p&gt;

&lt;h2 id=&quot;this-is-water&quot;&gt;2. This is Water&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;By David Foster Wallace&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/this_is_water.jpg&quot; alt=&quot;this is water&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在繁琐无聊的日常中，日复一日地保持自觉与警醒，困难得不可想象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;视频链接：&lt;a href=&quot;http://v.youku.com/v_show/id_XNjYyMjYzNDky.html?from=y1.2-1-103.3.4-1.1-1-1-3-0#paction&quot;&gt;生命中最简单又最困难的事&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2016年2月24日：写给将要参加工作的自己，莫要被生活所淹没，选择思考的方式，保持自觉与警醒。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3. 看见&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;柴静&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/kanjian.jpeg&quot; alt=&quot;kanjian&quot; /&gt;&lt;/p&gt;

&lt;p&gt;柴静的这本书，给我最大的震动便如书中所说的“真实自有万钧之力”，“人生是一个摆脱矇昧的过程”，要接近“真实”需要去感受的勇气和能力。能够感受才能够理解，在理解的基础上才能正确的思考，以接近“真实”，获取宽容的能力。但这需要一个过程，需要在生活中摔打和淬炼，要理解自己的弱点，也能理解别人的弱点，但要克服弱点并不是一个快速的过程，毕竟“如果人的弱点那么容易被克服，还要这么长的人生干什么”。而如果不正视自己的弱点，去感受和接受，时间只会带来经验的积累，却不会带来成长。&lt;/p&gt;

&lt;p&gt;感谢柴静这本书，让我知道了她“看见”的历程。虽然对于柴静人们各有褒贬，但既然能看见她的缺点和局限，也应能看到她的努力和思考，我相信今后的某个时刻，我会因为自己的生活，而回过头来再看这本书，寻求启发。毕竟柴静也是通过那么丰富的人生经历才能悟出一些道理，我也不可能只是靠多读几本书就能“看见”一切，还是要在真实的生活中磨砺。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;4. 最好的告别&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;By Atul Gavande&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/being_mortal.jpg&quot; alt=&quot;Being Mortal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是一本见证了太多生死的医生写出来的书，如果人能够仅仅因为衰老，而在爱的人的身边平静离去，那将是每个人都期望的告别。但这本书用实际的例子告诉我们，人的衰老是必然的，也许技术可以延长这个过程，但往往伴随着痛苦的代价。’being mortal’，我们都是凡人，会经历亲人的衰老，也会迎来自己的衰老，在这个过程之中，我们需要接受现实，去尽可能的选择亲人或自己更想要的结果，做最好的告别。&lt;/p&gt;

&lt;p&gt;很多豆瓣读者会说书中作者并没有说清楚什么时候应该放手，什么时候应该告别。但其实作者已经说的很清楚，告别的时机并不因该由医生决定，医生是作为一个解释者的角色，而决定主要来自于患者自身的意愿，而家人应该帮助患者找到最好的告别方式。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Apr 2016 12:49:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/read/2016/04/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%80%9D.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/read/2016/04/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%80%9D.html</guid>
        
        
        <category>Read</category>
        
      </item>
    
      <item>
        <title>程序小事</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jekyll-github&quot; id=&quot;markdown-toc-jekyll-github&quot;&gt;1. jekyll github发布问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;2. 准备的技能树&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;3. 今后工作状态&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#macsed&quot; id=&quot;markdown-toc-macsed&quot;&gt;4. Mac下sed问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;5. 为博客添加目录&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rescuetime&quot; id=&quot;markdown-toc-rescuetime&quot;&gt;6. 尝试使用rescuetime&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;7. 工作入职&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jekyll-github&quot;&gt;1. jekyll github发布问题&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;时间：2016年2月8日 晚&lt;/li&gt;
  &lt;li&gt;问题回放：在本地发布无问题的jekyll博客，在&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;到github上时迟迟不能显示。但如果把博客的创建时间设置为今天之前，则发布成功。&lt;/li&gt;
  &lt;li&gt;问题分析：目前还没有找到发生该问题的原因，不知道是否是因为github pages本身有这样的设置，正在调查中。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;jekyll博客的搭建和发布可参考:&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&quot;&gt;阮一峰的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;解答 2016年2月23日&lt;/h4&gt;
&lt;p&gt;github应该采用的是utc时间，只需要将博客的&lt;code class=&quot;highlighter-rouge&quot;&gt;yaml&lt;/code&gt;信息头中的	&lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt;参数进行时区设置，如果作者使用的是北京时间，则设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;+0800&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2. 准备的技能树&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;redis&lt;/li&gt;
  &lt;li&gt;zookeeper&lt;/li&gt;
  &lt;li&gt;spring(需要进阶)&lt;/li&gt;
  &lt;li&gt;rest&lt;/li&gt;
  &lt;li&gt;数据库(从mysql入手)&lt;/li&gt;
  &lt;li&gt;脚本&lt;/li&gt;
  &lt;li&gt;算法(需要进阶)&lt;/li&gt;
  &lt;li&gt;网络&lt;/li&gt;
  &lt;li&gt;javascript&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3. 今后工作状态&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在工作中游刃有余，同时保持对新技术的兴趣和尝试，参与到产品的设计和策划中。&lt;/li&gt;
  &lt;li&gt;未来事不可预知，不要过多的担忧，多思无益&lt;/li&gt;
  &lt;li&gt;不可能每次遇到问题都已做好准备，要冷静的去思考解决之法&lt;/li&gt;
  &lt;li&gt;谦虚而脚踏实地，与志同道合的人称为朋友，不要为不合的人烦扰&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;macsed&quot;&gt;4. Mac下sed问题&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sed -i &#39;&#39; &#39;1a test&#39; test&lt;/code&gt;时如果是&lt;code class=&quot;highlighter-rouge&quot;&gt;1a&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;1i&lt;/code&gt;都会报错，这应该是Mac自带的&lt;code class=&quot;highlighter-rouge&quot;&gt;sed&lt;/code&gt;问题，所以选择&lt;code class=&quot;highlighter-rouge&quot;&gt;brew install gnu-sed&lt;/code&gt;来替换掉，改用&lt;code class=&quot;highlighter-rouge&quot;&gt;gsed&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;5. 为博客添加目录&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gsed -i &#39;6a *内容目录\n{:toc}\n&#39; *.md&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;rescuetime&quot;&gt;6. 尝试使用rescuetime&lt;/h2&gt;

&lt;p&gt;时间管理应该是以后工作很重要的内容，尝试使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rescuetime&lt;/code&gt;来管理时间，之后可以对比下和番茄工作法的区别。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;7. 工作入职&lt;/h2&gt;

&lt;p&gt;这是入职的第三天，周围的同事给我感觉挺不错，在这个部门相信我能学到不少东西，加油吧少年，Be simple !&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Apr 2016 10:51:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/develop/2016/04/06/%E7%A8%8B%E5%BA%8F%E5%B0%8F%E4%BA%8B.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/develop/2016/04/06/%E7%A8%8B%E5%BA%8F%E5%B0%8F%E4%BA%8B.html</guid>
        
        
        <category>Develop</category>
        
      </item>
    
      <item>
        <title>Shell脚本实例</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#fileopen&quot; id=&quot;markdown-toc-fileopen&quot;&gt;fileopen命令实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#todo&quot; id=&quot;markdown-toc-todo&quot;&gt;todo命令实现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#valid-phone-numbers&quot; id=&quot;markdown-toc-valid-phone-numbers&quot;&gt;Valid Phone Numbers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#transpose-file&quot; id=&quot;markdown-toc-transpose-file&quot;&gt;Transpose File&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#word-frequency&quot; id=&quot;markdown-toc-word-frequency&quot;&gt;Word Frequency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fileopen&quot;&gt;fileopen命令实现&lt;/h2&gt;

&lt;p&gt;fileopen命令是为了实现Mac系统下，在终端中用应用打开文件。&lt;br /&gt;
首先将目录&lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/huanghuan/Work/MyCMD &lt;/code&gt;命令加入环境变量中，Mac下可配置在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/bashrc&lt;/code&gt;中。然后创建&lt;code class=&quot;highlighter-rouge&quot;&gt;fileopen&lt;/code&gt;文件，其内容为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1	#! /bin/sh
 2	if [ $# != 2 ]
 3	then
 4	    echo &quot;输入参数错误!&quot;
 5	else
 6	   search_result=`find /Applications -maxdepth 1  -name *${1}*.app | wc -l`
 7	   app_list=`find /Applications -maxdepth 1  -name *${1}*.app`
 8	   if (($search_result&amp;lt;=0))
 9	   then
10	       echo &quot;未找到对应程序&quot;
11	   elif (($search_result==1))
12	   then
13	       echo &quot;打开文件&quot;
14	       open ${app_list} ${2}
15	   else
16	       echo &quot;符合条件的程序有:\n${app_list}&quot;
17	       echo &quot;请重新输入正确的程序名&quot;
18	   fi
19	fi
20	exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;命令的运行效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/fileopen.png&quot; alt=&quot;fileopen命令&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PS:该命令将进一步完善，目前作为一个Shell练习而简单实现&lt;/p&gt;

&lt;h2 id=&quot;todo&quot;&gt;todo命令实现&lt;/h2&gt;

&lt;p&gt;todo命令实际上就是实现了一个toDoList的小命令，配置如fileopen命令，其内容为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1	#! /bin/sh
 2
 3	path=&quot;/Users/huanghuan/Work/MyCMD/toDoList&quot;
 4
 5	while getopts a:r: option
 6	do
 7	  case $option in
 8	       a)
 9	         echo ${OPTARG}&quot; 创建时间:&quot;`date +%Y年-%m月-%d日` &amp;gt;&amp;gt;$path
10	         ;;
11	       r)
12	         if [ -f &quot;$path&quot; ]
13	         then
14	             gsed -i &quot;${OPTARG}d&quot; $path
15	         fi
16	         ;;
17	       ?)
18	         echo &quot;Usage: toDo [-arp] [arg]&quot;
19	         echo &quot;-a add todo item&quot;
20	         echo &quot;-r remove todo item&quot;
21	         echo &quot;-p print todo List&quot;
22	         exit
23	         ;;
24	  esac
25	done
26
27	echo &quot;当前待办项目:&quot;
28	if [ -f &quot;$path&quot; ]
29	then
30	    cat -n $path
31	fi
32	exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;命令的运行效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/todo.png&quot; alt=&quot;todo命令&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该命令的扩展参见：&lt;a href=&quot;https://github.com/sadwxqezc/todo_cmd&quot;&gt;todo扩展&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;valid-phone-numbers&quot;&gt;Valid Phone Numbers&lt;/h2&gt;

&lt;p&gt;来源于Leetcode题目：&lt;a href=&quot;https://leetcode.com/problems/valid-phone-numbers/&quot;&gt;Valid Phone Numbers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.&lt;/p&gt;

&lt;p&gt;You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)&lt;/p&gt;

&lt;p&gt;You may also assume each line in the text file must not contain leading or trailing white spaces.&lt;/p&gt;

&lt;p&gt;For example, assume that file.txt has the following content:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;987-123-4567
123 456 7890
(123) 456-7890
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Your script should output the following valid phone numbers:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;987-123-4567
(123) 456-7890
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚本代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;grep -E &#39;^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$&#39; file.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-E&lt;/code&gt;可以少写很多转义字符，这道题还值得注意的是：&lt;a href=&quot;https://leetcode.com/discuss/29452/whats-the-difference-between-d-and-0-9-in-grep&quot;&gt;what’s the difference between \d and [0-9] in grep&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;transpose-file&quot;&gt;Transpose File&lt;/h2&gt;

&lt;p&gt;来源于Leetcode题目：&lt;a href=&quot;https://leetcode.com/problems/transpose-file/&quot;&gt;Transpose File&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given a text file file.txt, transpose its content.&lt;/p&gt;

&lt;p&gt;You may assume that each row has the same number of columns and each field is separated by the ‘ ‘ character.&lt;/p&gt;

&lt;p&gt;For example, if file.txt has the following content:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name age
alice 21
ryan 30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Output the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name alice ryan
age 21 30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚本代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;awk -F &#39; &#39; &#39;BEGIN{line=0;column=1} {while(column&amp;lt;=NF){array[line,column]=$column; column++;} line++;column=1;} END{for(i=1;i&amp;lt;=NF;i++){for(j=0;j&amp;lt;line;j++){printf(&quot;%s&quot;,array[j,i]);if(j&amp;lt;line-1){printf(&quot; &quot;)}} printf(&quot;\n&quot;);}}&#39; file.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;word-frequency&quot;&gt;Word Frequency&lt;/h2&gt;

&lt;p&gt;来源于Leetcode题目：&lt;a href=&quot;https://leetcode.com/problems/word-frequency/&quot;&gt;Word Frequency&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Write a bash script to calculate the frequency of each word in a text file words.txt.&lt;/p&gt;

&lt;p&gt;For simplicity sake, you may assume:&lt;/p&gt;

&lt;p&gt;words.txt contains only lowercase characters and space ‘ ‘ characters.
Each word must consist of lowercase characters only.
Words are separated by one or more whitespace characters.
For example, assume that words.txt has the following content:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;the day is sunny the the
the sunny is is
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Your script should output the following, sorted by descending frequency:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;the 4
is 3
sunny 2
day 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Note:
Don’t worry about handling ties, it is guaranteed that each word’s frequency count is unique.&lt;/p&gt;

&lt;p&gt;脚本代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sed &#39;s/ /\n/g&#39; words.txt | sed &#39;/^$/d&#39; | sort | uniq -c | sort -nr | awk -F &#39; &#39; &#39;{print $2&quot; &quot;$1}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 12:05:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/shell/2016/03/30/Shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E4%BE%8B.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/shell/2016/03/30/Shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E4%BE%8B.html</guid>
        
        
        <category>Shell</category>
        
      </item>
    
      <item>
        <title>算法练习</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;求二叉树的最大距离&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;求二叉树的最大距离&lt;/h3&gt;

&lt;p&gt;输入图例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/btree_max_distance.png&quot; alt=&quot;max distance of binary tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int max=0;

static int maxDepth(BinaryTreeNode root) {
    if (root == null) {
        return 0;
    }
    int maxLeft = (root.getLeft() == null) ? 0 : 1 + maxDepth(root.getLeft());
    int maxRight = (root.getRight() == null) ? 0 : 1 + maxDepth(root.getRight());
    int tempMax=maxLeft+maxRight;
    max=(tempMax&amp;gt;max)?tempMax:max;
    return (maxLeft&amp;gt;maxRight)?maxLeft:maxRight;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后max的值为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/max_distance_result.png&quot; alt=&quot;max distance result&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Mar 2016 10:13:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/algorithm/2016/03/30/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/algorithm/2016/03/30/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0.html</guid>
        
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Spring学习</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#spring&quot; id=&quot;markdown-toc-spring&quot;&gt;Spring关键特性范例&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;依赖注入和控制反转&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li&gt;参考书目：《Spring In Action》&lt;/li&gt;
  &lt;li&gt;IDE：Intellij Idea&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Spring框架已经是基于POJO的轻量级开发框架的领导者，其应用已十分广泛，它的根本使命是简化Java的开发过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;spring&quot;&gt;Spring关键特性范例&lt;/h2&gt;

&lt;p&gt;Spring的四种关键策略：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;基于POJO(Plain Ordinary java Object)的轻量级和最小侵入性编程&lt;/li&gt;
  &lt;li&gt;通过依赖注入(DI)和面向接口实现松耦合&lt;/li&gt;
  &lt;li&gt;基于切面(AOP)和惯例进行声明式编程&lt;/li&gt;
  &lt;li&gt;通过切面和模版减少样板式代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些特性或策略看起来总是让人头疼，还是通过一些例子来解释Spring的关键特性&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;依赖注入和控制反转&lt;/h3&gt;

&lt;p&gt;依赖注入的关键作用在于解耦合，将类与类之间的对象引用进行统一管理，其实现原理是Java的反射机制。&lt;/p&gt;

&lt;p&gt;下面举一个人骑车的例子：&lt;/p&gt;

&lt;p&gt;People类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1	package beijing.huangh.demos;
 2
 3	/**
 4	 * Created by huanghuan on 16/3/29.
 5	 */
 6	public class People {
 7	    private Bike bike;
 8
 9	    public People(Bike bike) {
10	        this.bike = bike;
11	    }
12
13	    public void ridingBike() {
14	        if (bike != null) {
15	            bike.ridingBike();
16	        }
17	    }
18	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Bike类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1	package beijing.huangh.demos;
 2
 3	/**
 4	 * Created by huanghuan on 16/3/29.
 5	 */
 6	public class Bike {
 7	    public void ridingBike() {
 8	        System.out.println(&quot;riding bike!!!&quot;);
 9	    }
10	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过xml文件进行装配：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1	&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
 2	&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
 3	       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 4	       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
 5
 6	       &amp;lt;bean id=&quot;bike&quot; class=&quot;beijing.huangh.demos.Bike&quot;/&amp;gt;
 7	       &amp;lt;bean id=&quot;people&quot; class=&quot;beijing.huangh.demos.People&quot;&amp;gt;
 8	              &amp;lt;constructor-arg ref=&quot;bike&quot;/&amp;gt;
 9	       &amp;lt;/bean&amp;gt;
10	&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用测试类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1	package beijing.huangh.test;
 2
 3	import beijing.huangh.demos.People;
 4	import org.springframework.context.ApplicationContext;
 5	import org.springframework.context.support.ClassPathXmlApplicationContext;
 6
 7	/**
 8	 * Created by huanghuan on 16/3/29.
 9	 */
10	public class DemoTest {
11	    public static void main(String[] args) {
12	        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);
13	        People people = (People) context.getBean(&quot;people&quot;);
14	        people.ridingBike();
15	    }
16	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/bike.png&quot; alt=&quot;依赖注入范例&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从这个范例中我们可以看出，类对象的构建和相互引用都由Spring的配置文件控制，&lt;code class=&quot;highlighter-rouge&quot;&gt;people&lt;/code&gt;对象所需要的&lt;code class=&quot;highlighter-rouge&quot;&gt;bike&lt;/code&gt;对象，也是由Spring框架通过构造器去注入。这样的方式咋看起来确实能够降低项目的复杂度，开发起来更加便捷，同时可以有效重用对象。但可以预见的是，当一个项目较为庞大，有多达数百个类，在这种情况下，如果依旧采用上诉的配置文件装配方法，整个配置文件将显得十分庞杂。而且IDE往往对框架的支持有限，要知道一个对象被注入了什么其它对象，恐怕只能进行不断的&lt;code class=&quot;highlighter-rouge&quot;&gt;file search&lt;/code&gt;了，Spring是否能解决我所说的问题了，我将在接下来的学习中寻找答案。&lt;/p&gt;

</description>
        <pubDate>Tue, 29 Mar 2016 18:38:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/framework/2016/03/29/Spring%E5%AD%A6%E4%B9%A0.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/framework/2016/03/29/Spring%E5%AD%A6%E4%B9%A0.html</guid>
        
        
        <category>Framework</category>
        
      </item>
    
      <item>
        <title>Linux命令大全 Part Two</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#thefuckmac&quot; id=&quot;markdown-toc-thefuckmac&quot;&gt;17. thefuck命令(Mac)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tarmac&quot; id=&quot;markdown-toc-tarmac&quot;&gt;18. tar命令(Mac)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#aliasmac&quot; id=&quot;markdown-toc-aliasmac&quot;&gt;19. alias命令(Mac)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chmodmac&quot; id=&quot;markdown-toc-chmodmac&quot;&gt;20. chmod命令(Mac)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pvmac&quot; id=&quot;markdown-toc-pvmac&quot;&gt;21. pv命令(Mac)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#bcmac&quot; id=&quot;markdown-toc-bcmac&quot;&gt;22. bc命令(Mac)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#uniq&quot; id=&quot;markdown-toc-uniq&quot;&gt;23. uniq命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#curlmac&quot; id=&quot;markdown-toc-curlmac&quot;&gt;24. curl命令(Mac)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#topfree&quot; id=&quot;markdown-toc-topfree&quot;&gt;25. top和free命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pastemac&quot; id=&quot;markdown-toc-pastemac&quot;&gt;26. paste命令(Mac)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cutmac&quot; id=&quot;markdown-toc-cutmac&quot;&gt;27. cut命令(Mac)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#lsof&quot; id=&quot;markdown-toc-lsof&quot;&gt;28. lsof命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;有趣的命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mac&quot; id=&quot;markdown-toc-mac&quot;&gt;几个好玩的命令（Mac）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;命令后带(Mac)标记的，表示该命令在Mac OSX下测试，其它的在Debian下测试。&lt;/p&gt;

&lt;h3 id=&quot;thefuckmac&quot;&gt;17. thefuck命令(Mac)&lt;/h3&gt;

&lt;p&gt;thefuck命令就是用在你想说&lt;code class=&quot;highlighter-rouge&quot;&gt;fuck&lt;/code&gt;的时候，它能够自动尝试修复有错误的命令&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;基本格式 fuck [option] &lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bashrc&lt;/code&gt;中设置&lt;code class=&quot;highlighter-rouge&quot;&gt;eval $(thefuck --alias)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;范例一：&lt;code&gt;git brnch&lt;/code&gt;后回车再输入&lt;code class=&quot;highlighter-rouge&quot;&gt;fuck&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/thefuck.png&quot; alt=&quot;fuck&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tarmac&quot;&gt;18. tar命令(Mac)&lt;/h3&gt;

&lt;p&gt;tar命令用于文件的解压或压缩&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;基本格式 tar [main option] [accessibility options] [filename or dir]&lt;/b&gt;&lt;/h4&gt;
&lt;h5&gt;&lt;b&gt;main option 主选项 三者有且只能有一个&lt;/b&gt;&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;-c&lt;/code&gt; 创建新的文件，相当于打包&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-x&lt;/code&gt; 释放文件，相当于拆包&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-t&lt;/code&gt; 列出档案文件的内容，查看已经备份了哪些文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;&lt;b&gt;accessibility options 辅助选项&lt;/b&gt;&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;-z&lt;/code&gt; 是否需要用gzip压缩或解压，一般格式为.tar.gz或者.tgz&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-j&lt;/code&gt; 是否需要用bzip2压缩或解压，一般格式为.tar.bz2&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 压缩过程中显示文件&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 使用文档名&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--exclude FILE&lt;/code&gt; 压缩过程中不要将File打包&amp;lt;/code&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-C dir&lt;/code&gt; 切换工作目录，参考:&lt;a href=&quot;http://www.cnblogs.com/li-hao/archive/2011/10/03/2198480.html&quot;&gt;Linux下使用tar命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;范例一：&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xzvf mbadolato-iTerm2-Color-Schemes-a646a1d.tar.gz&lt;/code&gt; 解压到当前文件夹&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/tar_xzvf.png&quot; alt=&quot;tar_xzvf&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例二：&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -tf mbadolato-iTerm2-Color-Schemes-a646a1d.tar.gz&lt;/code&gt; 显示压缩包中的文件目录，如果文件是用gizp压缩的需要加z参数&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/tar_tf.png&quot; alt=&quot;tar_tf&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例三：&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -cjvf ./test.bz2 ./mbadolato-iTerm2-Color-Schemes-a646a1d&lt;/code&gt; 压缩文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/tar_jcvf.png&quot; alt=&quot;tar_jcvf&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;aliasmac&quot;&gt;19. alias命令(Mac)&lt;/h3&gt;

&lt;p&gt;alias命令用来设定指令的别名，可以使用该命令将较长的命令简化。&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;基本格式 alias newCmd=&#39;originCmd [option]&#39;&lt;/b&gt;&lt;/h4&gt;

&lt;p&gt;范例一：&lt;code class=&quot;highlighter-rouge&quot;&gt;alias&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;alias -p&lt;/code&gt;显示已经定义的别名，可用&lt;code class=&quot;highlighter-rouge&quot;&gt;unalias&lt;/code&gt;命令删除别名&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/alias.png&quot; alt=&quot;alias&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例二：&lt;code class=&quot;highlighter-rouge&quot;&gt;alias ll=&#39;ls -lhaS&#39;&lt;/code&gt;可以缩短命令长度，如果要使该alias长期有效，需要写在系统环境变量中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/alias_ll.png&quot; alt=&quot;alias_ll&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;chmodmac&quot;&gt;20. chmod命令(Mac)&lt;/h3&gt;

&lt;p&gt;chmod命令用于设定文件或目录的权限，可以用数字或符号的方式进行设定，这里推荐用符号的方式&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;基本格式 chmod [option] [filename|dirname]&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-R&lt;/code&gt;递归的持续变更&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;范例一：&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod u-x,g+w,o=rwx function.sh&lt;/code&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;u&lt;/code&gt;表示文件所有者，&lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt;表示组用户，&lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;表示其它用户，&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;表示所有用户。而&lt;code class=&quot;highlighter-rouge&quot;&gt;-,+,=&lt;/code&gt;分别表示删除，增加和设定权限。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/chmod_ugo.png&quot; alt=&quot;chmod_ugo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例二：&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod a=rwx function.sh&lt;/code&gt;设定所有类型用户的权限&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/chmod_a.png&quot; alt=&quot;chmod_a&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考:&lt;a href=&quot;https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md&quot;&gt;命令行的艺术&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pvmac&quot;&gt;21. pv命令(Mac)&lt;/h3&gt;

&lt;p&gt;pv命令可以通过管道来显示数据的处理进度&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;基本格式 pv [option]&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;-p&lt;/code&gt; 显示百分比&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-t&lt;/code&gt; 显示时间&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-r&lt;/code&gt; 传输速率&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-e&lt;/code&gt; 估计的剩余时间&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-n&lt;/code&gt; 用数字代替进度条来显示百分比&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-L&lt;/code&gt; 限制传输速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;范例一：&lt;code&gt;pv ./12怒汉.mkv &amp;gt; ~/Work/Test/angry.mkv&lt;/code&gt; 显示拷贝的速度和百分比&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/pv.png&quot; alt=&quot;pv&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例二：&lt;code&gt;echo &#39;this is a pv test&#39; | pv -L 2&lt;/code&gt;  限制传输速度为2Bytes&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/pv_L.png&quot; alt=&quot;pv_L&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;bcmac&quot;&gt;22. bc命令(Mac)&lt;/h3&gt;

&lt;p&gt;bc命令可以用于计算&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;基本格式 bc [option]&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;-l&lt;/code&gt; 定义数学函数的库，并将初始值scale设定为20&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;范例一：&lt;code&gt;bc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/bc.png&quot; alt=&quot;bc&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;uniq&quot;&gt;23. uniq命令&lt;/h3&gt;

&lt;p&gt;参考:&lt;a href=&quot;http://sadwxqezc.github.io/HuangHuanBlog/linux/2016/02/11/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-Part-Four.html&quot;&gt;sort命令&lt;/a&gt;
uniq命令通常和sort命令合用，用于检查文本中重复出现的行列，但前提是重复行必须是相邻的。&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;基本格式 uniq [option] [filename] [outputfilename]&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;-c&lt;/code&gt; 显示该行重复出现的次数&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 仅仅显示重复出现的行列&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-u&lt;/code&gt; 仅显示出现一次的行列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;范例一：&lt;code class=&quot;highlighter-rouge&quot;&gt;sort sort.txt | uniq -c&lt;/code&gt;等命令结果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/uniq.png&quot; alt=&quot;uniq&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个好玩的命令站点：&lt;a href=&quot;http://www.commandlinefu.com/commands/browse/sort-by-votes&quot;&gt;Commandlinefu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/command.png&quot; alt=&quot;command&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;curlmac&quot;&gt;24. curl命令(Mac)&lt;/h3&gt;

&lt;p&gt;curl命令是一个非常强大的文件传输工具，利用，利用URL规则它支持文件的上传和下载。curl支持包括HTTP,HTTPS,Ftp等多种协议，同时支持Post，cookies，限速，认证等众多功能。&lt;/p&gt;

&lt;h4&gt;&lt;b&gt;基本格式 curl [option] [params]&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;-A&lt;/code&gt; 设置用户代理&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-c [file]&lt;/code&gt; 命令执行结束后将cookie写入到某个文件中&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-C [offset]&lt;/code&gt; 断点续传&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-e &lt;/code&gt;  设定来源网址&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-s &lt;/code&gt; 寂寞模式，不输出任何东西&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-S &lt;/code&gt; 显示错误&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-T [file] &lt;/code&gt; 上传文件&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-u &lt;/code&gt; 设置用户名和密码&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-o [filename]&lt;/code&gt; 将文件写入到某个文件中&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-O &lt;/code&gt; 将文件写入到本地文件，保存原始文件名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;范例一：&lt;code class=&quot;highlighter-rouge&quot;&gt;curl http://man.linuxde.net/test.iso -o filename.iso --progress&lt;/code&gt; 下载文件并显示进度条&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/curl_o.png&quot; alt=&quot;curl_o&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该命令功能较多，今后将进一步补充&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;topfree&quot;&gt;25. top和free命令&lt;/h3&gt;

&lt;p&gt;top命令实际上就是Linux下的“任务管理器”，能够实时的显示系统中各个进程的资源占用状况，默认刷新频率是5秒一次。&lt;/p&gt;

&lt;h4&gt;&lt;b&gt;基本格式 top [option]&lt;/b&gt;&lt;/h4&gt;

&lt;p&gt;快捷键：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt; 根据CPU占用排序&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; 根据内存使用大小排序&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; 根据时间/累计时间排序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;范例一: &lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt; 显示效果，前五行显示了启动时间，任务数，cpu，内存和交换分区等信息，之后是更详细的各个进程信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/top.png&quot; alt=&quot;top&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例二: &lt;code class=&quot;highlighter-rouge&quot;&gt;free -m&lt;/code&gt; 如果只想查看内存占用，同样可使用&lt;code class=&quot;highlighter-rouge&quot;&gt;free&lt;/code&gt;命令，一般选择按&lt;code class=&quot;highlighter-rouge&quot;&gt;MB&lt;/code&gt;显示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/free.png&quot; alt=&quot;free&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pastemac&quot;&gt;26. paste命令(Mac)&lt;/h3&gt;

&lt;p&gt;paste命令用于将多个文件的内容合并&lt;/p&gt;

&lt;h4&gt;&lt;b&gt;基本格式 paste [option] [filename]&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt; 串行处理而非平行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 设定间隔符号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;范例：&lt;code class=&quot;highlighter-rouge&quot;&gt;paste -s -d &#39;:&#39; test2 test1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/paste.png&quot; alt=&quot;paste&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cutmac&quot;&gt;27. cut命令(Mac)&lt;/h3&gt;

&lt;p&gt;cut命令用于在文件中剪切数据，以每一行为处理对象。&lt;/p&gt;

&lt;h4&gt;&lt;b&gt;基本格式 cut [option] [filename]&lt;/b&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-b&lt;/code&gt; 按字节分割，空格算一个字节，汉字三个字节&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt; 按字符分割&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; 按域分割&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 指定域分隔符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;范例一: &lt;code class=&quot;highlighter-rouge&quot;&gt;date | cut -b 1-7,9&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/cut_b.png&quot; alt=&quot;cut_b&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例二: &lt;code class=&quot;highlighter-rouge&quot;&gt;date | cut -c 1-5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/cut_c.png&quot; alt=&quot;cut_c&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例三: &lt;code class=&quot;highlighter-rouge&quot;&gt;date | cut -d &quot; &quot; -f 1-5 testColumn&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/cut_f.png&quot; alt=&quot;cut_f&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lsof&quot;&gt;28. lsof命令&lt;/h3&gt;

&lt;p&gt;在Linux中，一切都以文件的形式存在，包括常规数据，网络连接和硬件。而lsof(list open files)命令能够列出当前系统打开的文件，通过该命令可以查看进程和文件的占用关系。&lt;/p&gt;

&lt;h4&gt;&lt;b&gt;基本格式 lsof [option] [filename]&lt;/b&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt; 显示进程打开的文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt; 显示某进程号的进程打开的文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-i [46][TCP|UDP][@hostname|hostaddr][:service|port]&lt;/code&gt; 显示符合条件的进程情况&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;显示的内容：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COMMAND&lt;/code&gt; 进程名称&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PID&lt;/code&gt; 进程id&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;USER&lt;/code&gt; 进程所有者&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FD&lt;/code&gt; 文件描述符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DEVICE&lt;/code&gt; 指定磁盘的名称&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SIZE&lt;/code&gt; 文件大小&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NODE&lt;/code&gt; 索引节点（文件在磁盘的标志）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NAME&lt;/code&gt; 打开文件的确切名称（带绝对路径）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;范例一：&lt;code class=&quot;highlighter-rouge&quot;&gt;lsof -i:5000&lt;/code&gt; 该命令的作用类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;netstat -anp | grep 5000&lt;/code&gt;，可以根据端口号，查看是哪个进程占用了5000端口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/lsof_i.png&quot; alt=&quot;lsof -i port&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例二：&lt;code class=&quot;highlighter-rouge&quot;&gt;lsof catlina.out&lt;/code&gt; 查看tomcat的logs文件中的日志文件被占用情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/lsof.png&quot; alt=&quot;lsof file&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;有趣的命令&lt;/h3&gt;

&lt;p&gt;范例一：&lt;code class=&quot;highlighter-rouge&quot;&gt;cal -j 2 2016&lt;/code&gt;&lt;br /&gt;
显示2016年2月份的日历，标注当天为一年中的第几天&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/cal.png&quot; alt=&quot;cal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例二：screen在一个窗口中开启多个虚拟链接，适用于在screen的虚拟链接中运行脚本,不用再开新的窗口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;screen -S yourname //创建一个名为yourname的虚拟链接
jekyll serve //在yourname中启动一个jekyll
ctrl+a,d //保存并返回
screen -ls //查看所有的screen
screen -r yourname //返回该screen
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/screen.png&quot; alt=&quot;screen&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例三：column命令可以用于格式化文本，但仅仅适用于较为简单的文本&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/column.png&quot; alt=&quot;column&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例四：file命令可以查看对象类型&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/file.png&quot; alt=&quot;file&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例五：xargs命令的作用时将参数分段传输给其它命令，后面加-n1表示每次传入一个参数，-n2表示传入两个参数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/xargs.png&quot; alt=&quot;xargs&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例六：basename命令可用于去除文件的前缀，只获取文件名。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/basename.png&quot; alt=&quot;basename&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;mac&quot;&gt;几个好玩的命令（Mac）&lt;/h3&gt;

&lt;p&gt;范例一：&lt;code class=&quot;highlighter-rouge&quot;&gt;espeak haliluya&lt;/code&gt; 文本转语音命令，颇为有趣。Mac下可用&lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt;安装。&lt;/p&gt;

&lt;p&gt;范例二：&lt;code class=&quot;highlighter-rouge&quot;&gt;man ascii&lt;/code&gt; 可以方便的显示ascii 表&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/ascii.png&quot; alt=&quot;ascii&quot; /&gt;&lt;/p&gt;

&lt;p&gt;范例三：&lt;code class=&quot;highlighter-rouge&quot;&gt;time read&lt;/code&gt;计时器，按&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+D&lt;/code&gt;结束&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/time_read.png&quot; alt=&quot;time&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Mar 2016 11:47:00 +0800</pubDate>
        <link>http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/linux/2016/03/21/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8Part-II.html</link>
        <guid isPermaLink="true">http://sadwxqezc.github.io/HuangHuanBlog//HuangHuanBlog/linux/2016/03/21/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8Part-II.html</guid>
        
        
        <category>Linux</category>
        
      </item>
    
  </channel>
</rss>
